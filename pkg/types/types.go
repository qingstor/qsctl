// Code generated by go generate; DO NOT EDIT.
package types

import (
	"bytes"
	"sync"

	"github.com/Xuanwo/navvy"
	"github.com/Xuanwo/storage"
	"github.com/Xuanwo/storage/pkg/segment"
	"github.com/Xuanwo/storage/types"

	"github.com/yunify/qsctl/v2/pkg/fault"
	"github.com/yunify/qsctl/v2/pkg/schedule"
)

type BucketList struct {
	valid bool
	v     []string

	l sync.RWMutex
}

type BucketListGetter interface {
	GetBucketList() []string
}

func (o *BucketList) GetBucketList() []string {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("BucketList value is not valid")
	}
	return o.v
}

type BucketListSetter interface {
	SetBucketList([]string)
}

func (o *BucketList) SetBucketList(v []string) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type BucketListValidator interface {
	ValidateBucketList() bool
}

func (o *BucketList) ValidateBucketList() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadBucketList(t navvy.Task, v BucketListSetter) {
	x, ok := t.(interface {
		BucketListGetter
		BucketListValidator
	})
	if !ok {
		return
	}
	if !x.ValidateBucketList() {
		return
	}

	v.SetBucketList(x.GetBucketList())
}

type ByteSize struct {
	valid bool
	v     string

	l sync.RWMutex
}

type ByteSizeGetter interface {
	GetByteSize() string
}

func (o *ByteSize) GetByteSize() string {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("ByteSize value is not valid")
	}
	return o.v
}

type ByteSizeSetter interface {
	SetByteSize(string)
}

func (o *ByteSize) SetByteSize(v string) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ByteSizeValidator interface {
	ValidateByteSize() bool
}

func (o *ByteSize) ValidateByteSize() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadByteSize(t navvy.Task, v ByteSizeSetter) {
	x, ok := t.(interface {
		ByteSizeGetter
		ByteSizeValidator
	})
	if !ok {
		return
	}
	if !x.ValidateByteSize() {
		return
	}

	v.SetByteSize(x.GetByteSize())
}

type BytesPool struct {
	valid bool
	v     *sync.Pool

	l sync.RWMutex
}

type BytesPoolGetter interface {
	GetBytesPool() *sync.Pool
}

func (o *BytesPool) GetBytesPool() *sync.Pool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("BytesPool value is not valid")
	}
	return o.v
}

type BytesPoolSetter interface {
	SetBytesPool(*sync.Pool)
}

func (o *BytesPool) SetBytesPool(v *sync.Pool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type BytesPoolValidator interface {
	ValidateBytesPool() bool
}

func (o *BytesPool) ValidateBytesPool() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadBytesPool(t navvy.Task, v BytesPoolSetter) {
	x, ok := t.(interface {
		BytesPoolGetter
		BytesPoolValidator
	})
	if !ok {
		return
	}
	if !x.ValidateBytesPool() {
		return
	}

	v.SetBytesPool(x.GetBytesPool())
}

type Content struct {
	valid bool
	v     *bytes.Buffer

	l sync.RWMutex
}

type ContentGetter interface {
	GetContent() *bytes.Buffer
}

func (o *Content) GetContent() *bytes.Buffer {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Content value is not valid")
	}
	return o.v
}

type ContentSetter interface {
	SetContent(*bytes.Buffer)
}

func (o *Content) SetContent(v *bytes.Buffer) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ContentValidator interface {
	ValidateContent() bool
}

func (o *Content) ValidateContent() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadContent(t navvy.Task, v ContentSetter) {
	x, ok := t.(interface {
		ContentGetter
		ContentValidator
	})
	if !ok {
		return
	}
	if !x.ValidateContent() {
		return
	}

	v.SetContent(x.GetContent())
}

type DestinationPath struct {
	valid bool
	v     string

	l sync.RWMutex
}

type DestinationPathGetter interface {
	GetDestinationPath() string
}

func (o *DestinationPath) GetDestinationPath() string {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("DestinationPath value is not valid")
	}
	return o.v
}

type DestinationPathSetter interface {
	SetDestinationPath(string)
}

func (o *DestinationPath) SetDestinationPath(v string) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type DestinationPathValidator interface {
	ValidateDestinationPath() bool
}

func (o *DestinationPath) ValidateDestinationPath() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadDestinationPath(t navvy.Task, v DestinationPathSetter) {
	x, ok := t.(interface {
		DestinationPathGetter
		DestinationPathValidator
	})
	if !ok {
		return
	}
	if !x.ValidateDestinationPath() {
		return
	}

	v.SetDestinationPath(x.GetDestinationPath())
}

type DestinationService struct {
	valid bool
	v     storage.Servicer

	l sync.RWMutex
}

type DestinationServiceGetter interface {
	GetDestinationService() storage.Servicer
}

func (o *DestinationService) GetDestinationService() storage.Servicer {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("DestinationService value is not valid")
	}
	return o.v
}

type DestinationServiceSetter interface {
	SetDestinationService(storage.Servicer)
}

func (o *DestinationService) SetDestinationService(v storage.Servicer) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type DestinationServiceValidator interface {
	ValidateDestinationService() bool
}

func (o *DestinationService) ValidateDestinationService() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadDestinationService(t navvy.Task, v DestinationServiceSetter) {
	x, ok := t.(interface {
		DestinationServiceGetter
		DestinationServiceValidator
	})
	if !ok {
		return
	}
	if !x.ValidateDestinationService() {
		return
	}

	v.SetDestinationService(x.GetDestinationService())
}

type DestinationStorage struct {
	valid bool
	v     storage.Storager

	l sync.RWMutex
}

type DestinationStorageGetter interface {
	GetDestinationStorage() storage.Storager
}

func (o *DestinationStorage) GetDestinationStorage() storage.Storager {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("DestinationStorage value is not valid")
	}
	return o.v
}

type DestinationStorageSetter interface {
	SetDestinationStorage(storage.Storager)
}

func (o *DestinationStorage) SetDestinationStorage(v storage.Storager) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type DestinationStorageValidator interface {
	ValidateDestinationStorage() bool
}

func (o *DestinationStorage) ValidateDestinationStorage() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadDestinationStorage(t navvy.Task, v DestinationStorageSetter) {
	x, ok := t.(interface {
		DestinationStorageGetter
		DestinationStorageValidator
	})
	if !ok {
		return
	}
	if !x.ValidateDestinationStorage() {
		return
	}

	v.SetDestinationStorage(x.GetDestinationStorage())
}

type DestinationType struct {
	valid bool
	v     types.ObjectType

	l sync.RWMutex
}

type DestinationTypeGetter interface {
	GetDestinationType() types.ObjectType
}

func (o *DestinationType) GetDestinationType() types.ObjectType {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("DestinationType value is not valid")
	}
	return o.v
}

type DestinationTypeSetter interface {
	SetDestinationType(types.ObjectType)
}

func (o *DestinationType) SetDestinationType(v types.ObjectType) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type DestinationTypeValidator interface {
	ValidateDestinationType() bool
}

func (o *DestinationType) ValidateDestinationType() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadDestinationType(t navvy.Task, v DestinationTypeSetter) {
	x, ok := t.(interface {
		DestinationTypeGetter
		DestinationTypeValidator
	})
	if !ok {
		return
	}
	if !x.ValidateDestinationType() {
		return
	}

	v.SetDestinationType(x.GetDestinationType())
}

type Done struct {
	valid bool
	v     bool

	l sync.RWMutex
}

type DoneGetter interface {
	GetDone() bool
}

func (o *Done) GetDone() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Done value is not valid")
	}
	return o.v
}

type DoneSetter interface {
	SetDone(bool)
}

func (o *Done) SetDone(v bool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type DoneValidator interface {
	ValidateDone() bool
}

func (o *Done) ValidateDone() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadDone(t navvy.Task, v DoneSetter) {
	x, ok := t.(interface {
		DoneGetter
		DoneValidator
	})
	if !ok {
		return
	}
	if !x.ValidateDone() {
		return
	}

	v.SetDone(x.GetDone())
}

type EnableBenchmark struct {
	valid bool
	v     bool

	l sync.RWMutex
}

type EnableBenchmarkGetter interface {
	GetEnableBenchmark() bool
}

func (o *EnableBenchmark) GetEnableBenchmark() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("EnableBenchmark value is not valid")
	}
	return o.v
}

type EnableBenchmarkSetter interface {
	SetEnableBenchmark(bool)
}

func (o *EnableBenchmark) SetEnableBenchmark(v bool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type EnableBenchmarkValidator interface {
	ValidateEnableBenchmark() bool
}

func (o *EnableBenchmark) ValidateEnableBenchmark() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadEnableBenchmark(t navvy.Task, v EnableBenchmarkSetter) {
	x, ok := t.(interface {
		EnableBenchmarkGetter
		EnableBenchmarkValidator
	})
	if !ok {
		return
	}
	if !x.ValidateEnableBenchmark() {
		return
	}

	v.SetEnableBenchmark(x.GetEnableBenchmark())
}

type ExpectSize struct {
	valid bool
	v     int64

	l sync.RWMutex
}

type ExpectSizeGetter interface {
	GetExpectSize() int64
}

func (o *ExpectSize) GetExpectSize() int64 {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("ExpectSize value is not valid")
	}
	return o.v
}

type ExpectSizeSetter interface {
	SetExpectSize(int64)
}

func (o *ExpectSize) SetExpectSize(v int64) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ExpectSizeValidator interface {
	ValidateExpectSize() bool
}

func (o *ExpectSize) ValidateExpectSize() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadExpectSize(t navvy.Task, v ExpectSizeSetter) {
	x, ok := t.(interface {
		ExpectSizeGetter
		ExpectSizeValidator
	})
	if !ok {
		return
	}
	if !x.ValidateExpectSize() {
		return
	}

	v.SetExpectSize(x.GetExpectSize())
}

type Expire struct {
	valid bool
	v     int

	l sync.RWMutex
}

type ExpireGetter interface {
	GetExpire() int
}

func (o *Expire) GetExpire() int {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Expire value is not valid")
	}
	return o.v
}

type ExpireSetter interface {
	SetExpire(int)
}

func (o *Expire) SetExpire(v int) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ExpireValidator interface {
	ValidateExpire() bool
}

func (o *Expire) ValidateExpire() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadExpire(t navvy.Task, v ExpireSetter) {
	x, ok := t.(interface {
		ExpireGetter
		ExpireValidator
	})
	if !ok {
		return
	}
	if !x.ValidateExpire() {
		return
	}

	v.SetExpire(x.GetExpire())
}

type Fault struct {
	valid bool
	v     *fault.Fault

	l sync.RWMutex
}

type FaultGetter interface {
	GetFault() *fault.Fault
}

func (o *Fault) GetFault() *fault.Fault {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Fault value is not valid")
	}
	return o.v
}

type FaultSetter interface {
	SetFault(*fault.Fault)
}

func (o *Fault) SetFault(v *fault.Fault) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type FaultValidator interface {
	ValidateFault() bool
}

func (o *Fault) ValidateFault() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadFault(t navvy.Task, v FaultSetter) {
	x, ok := t.(interface {
		FaultGetter
		FaultValidator
	})
	if !ok {
		return
	}
	if !x.ValidateFault() {
		return
	}

	v.SetFault(x.GetFault())
}

type Force struct {
	valid bool
	v     bool

	l sync.RWMutex
}

type ForceGetter interface {
	GetForce() bool
}

func (o *Force) GetForce() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Force value is not valid")
	}
	return o.v
}

type ForceSetter interface {
	SetForce(bool)
}

func (o *Force) SetForce(v bool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ForceValidator interface {
	ValidateForce() bool
}

func (o *Force) ValidateForce() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadForce(t navvy.Task, v ForceSetter) {
	x, ok := t.(interface {
		ForceGetter
		ForceValidator
	})
	if !ok {
		return
	}
	if !x.ValidateForce() {
		return
	}

	v.SetForce(x.GetForce())
}

type HumanReadable struct {
	valid bool
	v     bool

	l sync.RWMutex
}

type HumanReadableGetter interface {
	GetHumanReadable() bool
}

func (o *HumanReadable) GetHumanReadable() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("HumanReadable value is not valid")
	}
	return o.v
}

type HumanReadableSetter interface {
	SetHumanReadable(bool)
}

func (o *HumanReadable) SetHumanReadable(v bool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type HumanReadableValidator interface {
	ValidateHumanReadable() bool
}

func (o *HumanReadable) ValidateHumanReadable() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadHumanReadable(t navvy.Task, v HumanReadableSetter) {
	x, ok := t.(interface {
		HumanReadableGetter
		HumanReadableValidator
	})
	if !ok {
		return
	}
	if !x.ValidateHumanReadable() {
		return
	}

	v.SetHumanReadable(x.GetHumanReadable())
}

type ID struct {
	valid bool
	v     string

	l sync.RWMutex
}

type IDGetter interface {
	GetID() string
}

func (o *ID) GetID() string {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("ID value is not valid")
	}
	return o.v
}

type IDSetter interface {
	SetID(string)
}

func (o *ID) SetID(v string) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type IDValidator interface {
	ValidateID() bool
}

func (o *ID) ValidateID() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadID(t navvy.Task, v IDSetter) {
	x, ok := t.(interface {
		IDGetter
		IDValidator
	})
	if !ok {
		return
	}
	if !x.ValidateID() {
		return
	}

	v.SetID(x.GetID())
}

type LongFormat struct {
	valid bool
	v     bool

	l sync.RWMutex
}

type LongFormatGetter interface {
	GetLongFormat() bool
}

func (o *LongFormat) GetLongFormat() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("LongFormat value is not valid")
	}
	return o.v
}

type LongFormatSetter interface {
	SetLongFormat(bool)
}

func (o *LongFormat) SetLongFormat(v bool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type LongFormatValidator interface {
	ValidateLongFormat() bool
}

func (o *LongFormat) ValidateLongFormat() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadLongFormat(t navvy.Task, v LongFormatSetter) {
	x, ok := t.(interface {
		LongFormatGetter
		LongFormatValidator
	})
	if !ok {
		return
	}
	if !x.ValidateLongFormat() {
		return
	}

	v.SetLongFormat(x.GetLongFormat())
}

type MD5Sum struct {
	valid bool
	v     []byte

	l sync.RWMutex
}

type MD5SumGetter interface {
	GetMD5Sum() []byte
}

func (o *MD5Sum) GetMD5Sum() []byte {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("MD5Sum value is not valid")
	}
	return o.v
}

type MD5SumSetter interface {
	SetMD5Sum([]byte)
}

func (o *MD5Sum) SetMD5Sum(v []byte) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type MD5SumValidator interface {
	ValidateMD5Sum() bool
}

func (o *MD5Sum) ValidateMD5Sum() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadMD5Sum(t navvy.Task, v MD5SumSetter) {
	x, ok := t.(interface {
		MD5SumGetter
		MD5SumValidator
	})
	if !ok {
		return
	}
	if !x.ValidateMD5Sum() {
		return
	}

	v.SetMD5Sum(x.GetMD5Sum())
}

type Name struct {
	valid bool
	v     string

	l sync.RWMutex
}

type NameGetter interface {
	GetName() string
}

func (o *Name) GetName() string {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Name value is not valid")
	}
	return o.v
}

type NameSetter interface {
	SetName(string)
}

func (o *Name) SetName(v string) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type NameValidator interface {
	ValidateName() bool
}

func (o *Name) ValidateName() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadName(t navvy.Task, v NameSetter) {
	x, ok := t.(interface {
		NameGetter
		NameValidator
	})
	if !ok {
		return
	}
	if !x.ValidateName() {
		return
	}

	v.SetName(x.GetName())
}

type Object struct {
	valid bool
	v     *types.Object

	l sync.RWMutex
}

type ObjectGetter interface {
	GetObject() *types.Object
}

func (o *Object) GetObject() *types.Object {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Object value is not valid")
	}
	return o.v
}

type ObjectSetter interface {
	SetObject(*types.Object)
}

func (o *Object) SetObject(v *types.Object) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ObjectValidator interface {
	ValidateObject() bool
}

func (o *Object) ValidateObject() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadObject(t navvy.Task, v ObjectSetter) {
	x, ok := t.(interface {
		ObjectGetter
		ObjectValidator
	})
	if !ok {
		return
	}
	if !x.ValidateObject() {
		return
	}

	v.SetObject(x.GetObject())
}

type ObjectChannel struct {
	valid bool
	v     chan *types.Object

	l sync.RWMutex
}

type ObjectChannelGetter interface {
	GetObjectChannel() chan *types.Object
}

func (o *ObjectChannel) GetObjectChannel() chan *types.Object {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("ObjectChannel value is not valid")
	}
	return o.v
}

type ObjectChannelSetter interface {
	SetObjectChannel(chan *types.Object)
}

func (o *ObjectChannel) SetObjectChannel(v chan *types.Object) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ObjectChannelValidator interface {
	ValidateObjectChannel() bool
}

func (o *ObjectChannel) ValidateObjectChannel() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadObjectChannel(t navvy.Task, v ObjectChannelSetter) {
	x, ok := t.(interface {
		ObjectChannelGetter
		ObjectChannelValidator
	})
	if !ok {
		return
	}
	if !x.ValidateObjectChannel() {
		return
	}

	v.SetObjectChannel(x.GetObjectChannel())
}

type ObjectLongList struct {
	valid bool
	v     *[][]string

	l sync.RWMutex
}

type ObjectLongListGetter interface {
	GetObjectLongList() *[][]string
}

func (o *ObjectLongList) GetObjectLongList() *[][]string {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("ObjectLongList value is not valid")
	}
	return o.v
}

type ObjectLongListSetter interface {
	SetObjectLongList(*[][]string)
}

func (o *ObjectLongList) SetObjectLongList(v *[][]string) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ObjectLongListValidator interface {
	ValidateObjectLongList() bool
}

func (o *ObjectLongList) ValidateObjectLongList() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadObjectLongList(t navvy.Task, v ObjectLongListSetter) {
	x, ok := t.(interface {
		ObjectLongListGetter
		ObjectLongListValidator
	})
	if !ok {
		return
	}
	if !x.ValidateObjectLongList() {
		return
	}

	v.SetObjectLongList(x.GetObjectLongList())
}

type Offset struct {
	valid bool
	v     int64

	l sync.RWMutex
}

type OffsetGetter interface {
	GetOffset() int64
}

func (o *Offset) GetOffset() int64 {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Offset value is not valid")
	}
	return o.v
}

type OffsetSetter interface {
	SetOffset(int64)
}

func (o *Offset) SetOffset(v int64) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type OffsetValidator interface {
	ValidateOffset() bool
}

func (o *Offset) ValidateOffset() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadOffset(t navvy.Task, v OffsetSetter) {
	x, ok := t.(interface {
		OffsetGetter
		OffsetValidator
	})
	if !ok {
		return
	}
	if !x.ValidateOffset() {
		return
	}

	v.SetOffset(x.GetOffset())
}

type PartNumber struct {
	valid bool
	v     int

	l sync.RWMutex
}

type PartNumberGetter interface {
	GetPartNumber() int
}

func (o *PartNumber) GetPartNumber() int {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("PartNumber value is not valid")
	}
	return o.v
}

type PartNumberSetter interface {
	SetPartNumber(int)
}

func (o *PartNumber) SetPartNumber(v int) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type PartNumberValidator interface {
	ValidatePartNumber() bool
}

func (o *PartNumber) ValidatePartNumber() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadPartNumber(t navvy.Task, v PartNumberSetter) {
	x, ok := t.(interface {
		PartNumberGetter
		PartNumberValidator
	})
	if !ok {
		return
	}
	if !x.ValidatePartNumber() {
		return
	}

	v.SetPartNumber(x.GetPartNumber())
}

type PartSize struct {
	valid bool
	v     int64

	l sync.RWMutex
}

type PartSizeGetter interface {
	GetPartSize() int64
}

func (o *PartSize) GetPartSize() int64 {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("PartSize value is not valid")
	}
	return o.v
}

type PartSizeSetter interface {
	SetPartSize(int64)
}

func (o *PartSize) SetPartSize(v int64) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type PartSizeValidator interface {
	ValidatePartSize() bool
}

func (o *PartSize) ValidatePartSize() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadPartSize(t navvy.Task, v PartSizeSetter) {
	x, ok := t.(interface {
		PartSizeGetter
		PartSizeValidator
	})
	if !ok {
		return
	}
	if !x.ValidatePartSize() {
		return
	}

	v.SetPartSize(x.GetPartSize())
}

type Path struct {
	valid bool
	v     string

	l sync.RWMutex
}

type PathGetter interface {
	GetPath() string
}

func (o *Path) GetPath() string {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Path value is not valid")
	}
	return o.v
}

type PathSetter interface {
	SetPath(string)
}

func (o *Path) SetPath(v string) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type PathValidator interface {
	ValidatePath() bool
}

func (o *Path) ValidatePath() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadPath(t navvy.Task, v PathSetter) {
	x, ok := t.(interface {
		PathGetter
		PathValidator
	})
	if !ok {
		return
	}
	if !x.ValidatePath() {
		return
	}

	v.SetPath(x.GetPath())
}

type PathScheduleFunc struct {
	valid bool
	v     pathScheduleFunc

	l sync.RWMutex
}

type PathScheduleFuncGetter interface {
	GetPathScheduleFunc() pathScheduleFunc
}

func (o *PathScheduleFunc) GetPathScheduleFunc() pathScheduleFunc {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("PathScheduleFunc value is not valid")
	}
	return o.v
}

type PathScheduleFuncSetter interface {
	SetPathScheduleFunc(pathScheduleFunc)
}

func (o *PathScheduleFunc) SetPathScheduleFunc(v pathScheduleFunc) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type PathScheduleFuncValidator interface {
	ValidatePathScheduleFunc() bool
}

func (o *PathScheduleFunc) ValidatePathScheduleFunc() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadPathScheduleFunc(t navvy.Task, v PathScheduleFuncSetter) {
	x, ok := t.(interface {
		PathScheduleFuncGetter
		PathScheduleFuncValidator
	})
	if !ok {
		return
	}
	if !x.ValidatePathScheduleFunc() {
		return
	}

	v.SetPathScheduleFunc(x.GetPathScheduleFunc())
}

type Pool struct {
	valid bool
	v     *navvy.Pool

	l sync.RWMutex
}

type PoolGetter interface {
	GetPool() *navvy.Pool
}

func (o *Pool) GetPool() *navvy.Pool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Pool value is not valid")
	}
	return o.v
}

type PoolSetter interface {
	SetPool(*navvy.Pool)
}

func (o *Pool) SetPool(v *navvy.Pool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type PoolValidator interface {
	ValidatePool() bool
}

func (o *Pool) ValidatePool() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadPool(t navvy.Task, v PoolSetter) {
	x, ok := t.(interface {
		PoolGetter
		PoolValidator
	})
	if !ok {
		return
	}
	if !x.ValidatePool() {
		return
	}

	v.SetPool(x.GetPool())
}

type ReadableSize struct {
	valid bool
	v     string

	l sync.RWMutex
}

type ReadableSizeGetter interface {
	GetReadableSize() string
}

func (o *ReadableSize) GetReadableSize() string {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("ReadableSize value is not valid")
	}
	return o.v
}

type ReadableSizeSetter interface {
	SetReadableSize(string)
}

func (o *ReadableSize) SetReadableSize(v string) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ReadableSizeValidator interface {
	ValidateReadableSize() bool
}

func (o *ReadableSize) ValidateReadableSize() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadReadableSize(t navvy.Task, v ReadableSizeSetter) {
	x, ok := t.(interface {
		ReadableSizeGetter
		ReadableSizeValidator
	})
	if !ok {
		return
	}
	if !x.ValidateReadableSize() {
		return
	}

	v.SetReadableSize(x.GetReadableSize())
}

type Recursive struct {
	valid bool
	v     bool

	l sync.RWMutex
}

type RecursiveGetter interface {
	GetRecursive() bool
}

func (o *Recursive) GetRecursive() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Recursive value is not valid")
	}
	return o.v
}

type RecursiveSetter interface {
	SetRecursive(bool)
}

func (o *Recursive) SetRecursive(v bool) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type RecursiveValidator interface {
	ValidateRecursive() bool
}

func (o *Recursive) ValidateRecursive() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadRecursive(t navvy.Task, v RecursiveSetter) {
	x, ok := t.(interface {
		RecursiveGetter
		RecursiveValidator
	})
	if !ok {
		return
	}
	if !x.ValidateRecursive() {
		return
	}

	v.SetRecursive(x.GetRecursive())
}

type ScheduleFunc struct {
	valid bool
	v     schedule.TaskFunc

	l sync.RWMutex
}

type ScheduleFuncGetter interface {
	GetScheduleFunc() schedule.TaskFunc
}

func (o *ScheduleFunc) GetScheduleFunc() schedule.TaskFunc {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("ScheduleFunc value is not valid")
	}
	return o.v
}

type ScheduleFuncSetter interface {
	SetScheduleFunc(schedule.TaskFunc)
}

func (o *ScheduleFunc) SetScheduleFunc(v schedule.TaskFunc) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ScheduleFuncValidator interface {
	ValidateScheduleFunc() bool
}

func (o *ScheduleFunc) ValidateScheduleFunc() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadScheduleFunc(t navvy.Task, v ScheduleFuncSetter) {
	x, ok := t.(interface {
		ScheduleFuncGetter
		ScheduleFuncValidator
	})
	if !ok {
		return
	}
	if !x.ValidateScheduleFunc() {
		return
	}

	v.SetScheduleFunc(x.GetScheduleFunc())
}

type Scheduler struct {
	valid bool
	v     schedule.Scheduler

	l sync.RWMutex
}

type SchedulerGetter interface {
	GetScheduler() schedule.Scheduler
}

func (o *Scheduler) GetScheduler() schedule.Scheduler {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Scheduler value is not valid")
	}
	return o.v
}

type SchedulerSetter interface {
	SetScheduler(schedule.Scheduler)
}

func (o *Scheduler) SetScheduler(v schedule.Scheduler) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type SchedulerValidator interface {
	ValidateScheduler() bool
}

func (o *Scheduler) ValidateScheduler() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadScheduler(t navvy.Task, v SchedulerSetter) {
	x, ok := t.(interface {
		SchedulerGetter
		SchedulerValidator
	})
	if !ok {
		return
	}
	if !x.ValidateScheduler() {
		return
	}

	v.SetScheduler(x.GetScheduler())
}

type SegmentChannel struct {
	valid bool
	v     chan *segment.Segment

	l sync.RWMutex
}

type SegmentChannelGetter interface {
	GetSegmentChannel() chan *segment.Segment
}

func (o *SegmentChannel) GetSegmentChannel() chan *segment.Segment {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("SegmentChannel value is not valid")
	}
	return o.v
}

type SegmentChannelSetter interface {
	SetSegmentChannel(chan *segment.Segment)
}

func (o *SegmentChannel) SetSegmentChannel(v chan *segment.Segment) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type SegmentChannelValidator interface {
	ValidateSegmentChannel() bool
}

func (o *SegmentChannel) ValidateSegmentChannel() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadSegmentChannel(t navvy.Task, v SegmentChannelSetter) {
	x, ok := t.(interface {
		SegmentChannelGetter
		SegmentChannelValidator
	})
	if !ok {
		return
	}
	if !x.ValidateSegmentChannel() {
		return
	}

	v.SetSegmentChannel(x.GetSegmentChannel())
}

type SegmentID struct {
	valid bool
	v     string

	l sync.RWMutex
}

type SegmentIDGetter interface {
	GetSegmentID() string
}

func (o *SegmentID) GetSegmentID() string {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("SegmentID value is not valid")
	}
	return o.v
}

type SegmentIDSetter interface {
	SetSegmentID(string)
}

func (o *SegmentID) SetSegmentID(v string) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type SegmentIDValidator interface {
	ValidateSegmentID() bool
}

func (o *SegmentID) ValidateSegmentID() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadSegmentID(t navvy.Task, v SegmentIDSetter) {
	x, ok := t.(interface {
		SegmentIDGetter
		SegmentIDValidator
	})
	if !ok {
		return
	}
	if !x.ValidateSegmentID() {
		return
	}

	v.SetSegmentID(x.GetSegmentID())
}

type SegmentIDScheduleFunc struct {
	valid bool
	v     segmentIDScheduleFunc

	l sync.RWMutex
}

type SegmentIDScheduleFuncGetter interface {
	GetSegmentIDScheduleFunc() segmentIDScheduleFunc
}

func (o *SegmentIDScheduleFunc) GetSegmentIDScheduleFunc() segmentIDScheduleFunc {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("SegmentIDScheduleFunc value is not valid")
	}
	return o.v
}

type SegmentIDScheduleFuncSetter interface {
	SetSegmentIDScheduleFunc(segmentIDScheduleFunc)
}

func (o *SegmentIDScheduleFunc) SetSegmentIDScheduleFunc(v segmentIDScheduleFunc) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type SegmentIDScheduleFuncValidator interface {
	ValidateSegmentIDScheduleFunc() bool
}

func (o *SegmentIDScheduleFunc) ValidateSegmentIDScheduleFunc() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadSegmentIDScheduleFunc(t navvy.Task, v SegmentIDScheduleFuncSetter) {
	x, ok := t.(interface {
		SegmentIDScheduleFuncGetter
		SegmentIDScheduleFuncValidator
	})
	if !ok {
		return
	}
	if !x.ValidateSegmentIDScheduleFunc() {
		return
	}

	v.SetSegmentIDScheduleFunc(x.GetSegmentIDScheduleFunc())
}

type Service struct {
	valid bool
	v     storage.Servicer

	l sync.RWMutex
}

type ServiceGetter interface {
	GetService() storage.Servicer
}

func (o *Service) GetService() storage.Servicer {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Service value is not valid")
	}
	return o.v
}

type ServiceSetter interface {
	SetService(storage.Servicer)
}

func (o *Service) SetService(v storage.Servicer) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ServiceValidator interface {
	ValidateService() bool
}

func (o *Service) ValidateService() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadService(t navvy.Task, v ServiceSetter) {
	x, ok := t.(interface {
		ServiceGetter
		ServiceValidator
	})
	if !ok {
		return
	}
	if !x.ValidateService() {
		return
	}

	v.SetService(x.GetService())
}

type Size struct {
	valid bool
	v     int64

	l sync.RWMutex
}

type SizeGetter interface {
	GetSize() int64
}

func (o *Size) GetSize() int64 {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Size value is not valid")
	}
	return o.v
}

type SizeSetter interface {
	SetSize(int64)
}

func (o *Size) SetSize(v int64) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type SizeValidator interface {
	ValidateSize() bool
}

func (o *Size) ValidateSize() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadSize(t navvy.Task, v SizeSetter) {
	x, ok := t.(interface {
		SizeGetter
		SizeValidator
	})
	if !ok {
		return
	}
	if !x.ValidateSize() {
		return
	}

	v.SetSize(x.GetSize())
}

type SourcePath struct {
	valid bool
	v     string

	l sync.RWMutex
}

type SourcePathGetter interface {
	GetSourcePath() string
}

func (o *SourcePath) GetSourcePath() string {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("SourcePath value is not valid")
	}
	return o.v
}

type SourcePathSetter interface {
	SetSourcePath(string)
}

func (o *SourcePath) SetSourcePath(v string) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type SourcePathValidator interface {
	ValidateSourcePath() bool
}

func (o *SourcePath) ValidateSourcePath() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadSourcePath(t navvy.Task, v SourcePathSetter) {
	x, ok := t.(interface {
		SourcePathGetter
		SourcePathValidator
	})
	if !ok {
		return
	}
	if !x.ValidateSourcePath() {
		return
	}

	v.SetSourcePath(x.GetSourcePath())
}

type SourceService struct {
	valid bool
	v     storage.Servicer

	l sync.RWMutex
}

type SourceServiceGetter interface {
	GetSourceService() storage.Servicer
}

func (o *SourceService) GetSourceService() storage.Servicer {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("SourceService value is not valid")
	}
	return o.v
}

type SourceServiceSetter interface {
	SetSourceService(storage.Servicer)
}

func (o *SourceService) SetSourceService(v storage.Servicer) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type SourceServiceValidator interface {
	ValidateSourceService() bool
}

func (o *SourceService) ValidateSourceService() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadSourceService(t navvy.Task, v SourceServiceSetter) {
	x, ok := t.(interface {
		SourceServiceGetter
		SourceServiceValidator
	})
	if !ok {
		return
	}
	if !x.ValidateSourceService() {
		return
	}

	v.SetSourceService(x.GetSourceService())
}

type SourceStorage struct {
	valid bool
	v     storage.Storager

	l sync.RWMutex
}

type SourceStorageGetter interface {
	GetSourceStorage() storage.Storager
}

func (o *SourceStorage) GetSourceStorage() storage.Storager {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("SourceStorage value is not valid")
	}
	return o.v
}

type SourceStorageSetter interface {
	SetSourceStorage(storage.Storager)
}

func (o *SourceStorage) SetSourceStorage(v storage.Storager) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type SourceStorageValidator interface {
	ValidateSourceStorage() bool
}

func (o *SourceStorage) ValidateSourceStorage() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadSourceStorage(t navvy.Task, v SourceStorageSetter) {
	x, ok := t.(interface {
		SourceStorageGetter
		SourceStorageValidator
	})
	if !ok {
		return
	}
	if !x.ValidateSourceStorage() {
		return
	}

	v.SetSourceStorage(x.GetSourceStorage())
}

type SourceType struct {
	valid bool
	v     types.ObjectType

	l sync.RWMutex
}

type SourceTypeGetter interface {
	GetSourceType() types.ObjectType
}

func (o *SourceType) GetSourceType() types.ObjectType {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("SourceType value is not valid")
	}
	return o.v
}

type SourceTypeSetter interface {
	SetSourceType(types.ObjectType)
}

func (o *SourceType) SetSourceType(v types.ObjectType) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type SourceTypeValidator interface {
	ValidateSourceType() bool
}

func (o *SourceType) ValidateSourceType() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadSourceType(t navvy.Task, v SourceTypeSetter) {
	x, ok := t.(interface {
		SourceTypeGetter
		SourceTypeValidator
	})
	if !ok {
		return
	}
	if !x.ValidateSourceType() {
		return
	}

	v.SetSourceType(x.GetSourceType())
}

type Storage struct {
	valid bool
	v     storage.Storager

	l sync.RWMutex
}

type StorageGetter interface {
	GetStorage() storage.Storager
}

func (o *Storage) GetStorage() storage.Storager {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Storage value is not valid")
	}
	return o.v
}

type StorageSetter interface {
	SetStorage(storage.Storager)
}

func (o *Storage) SetStorage(v storage.Storager) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type StorageValidator interface {
	ValidateStorage() bool
}

func (o *Storage) ValidateStorage() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadStorage(t navvy.Task, v StorageSetter) {
	x, ok := t.(interface {
		StorageGetter
		StorageValidator
	})
	if !ok {
		return
	}
	if !x.ValidateStorage() {
		return
	}

	v.SetStorage(x.GetStorage())
}

type StorageName struct {
	valid bool
	v     string

	l sync.RWMutex
}

type StorageNameGetter interface {
	GetStorageName() string
}

func (o *StorageName) GetStorageName() string {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("StorageName value is not valid")
	}
	return o.v
}

type StorageNameSetter interface {
	SetStorageName(string)
}

func (o *StorageName) SetStorageName(v string) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type StorageNameValidator interface {
	ValidateStorageName() bool
}

func (o *StorageName) ValidateStorageName() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadStorageName(t navvy.Task, v StorageNameSetter) {
	x, ok := t.(interface {
		StorageNameGetter
		StorageNameValidator
	})
	if !ok {
		return
	}
	if !x.ValidateStorageName() {
		return
	}

	v.SetStorageName(x.GetStorageName())
}

type TotalSize struct {
	valid bool
	v     int64

	l sync.RWMutex
}

type TotalSizeGetter interface {
	GetTotalSize() int64
}

func (o *TotalSize) GetTotalSize() int64 {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("TotalSize value is not valid")
	}
	return o.v
}

type TotalSizeSetter interface {
	SetTotalSize(int64)
}

func (o *TotalSize) SetTotalSize(v int64) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type TotalSizeValidator interface {
	ValidateTotalSize() bool
}

func (o *TotalSize) ValidateTotalSize() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadTotalSize(t navvy.Task, v TotalSizeSetter) {
	x, ok := t.(interface {
		TotalSizeGetter
		TotalSizeValidator
	})
	if !ok {
		return
	}
	if !x.ValidateTotalSize() {
		return
	}

	v.SetTotalSize(x.GetTotalSize())
}

type Type struct {
	valid bool
	v     types.ObjectType

	l sync.RWMutex
}

type TypeGetter interface {
	GetType() types.ObjectType
}

func (o *Type) GetType() types.ObjectType {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Type value is not valid")
	}
	return o.v
}

type TypeSetter interface {
	SetType(types.ObjectType)
}

func (o *Type) SetType(v types.ObjectType) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type TypeValidator interface {
	ValidateType() bool
}

func (o *Type) ValidateType() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadType(t navvy.Task, v TypeSetter) {
	x, ok := t.(interface {
		TypeGetter
		TypeValidator
	})
	if !ok {
		return
	}
	if !x.ValidateType() {
		return
	}

	v.SetType(x.GetType())
}

type URL struct {
	valid bool
	v     string

	l sync.RWMutex
}

type URLGetter interface {
	GetURL() string
}

func (o *URL) GetURL() string {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("URL value is not valid")
	}
	return o.v
}

type URLSetter interface {
	SetURL(string)
}

func (o *URL) SetURL(v string) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type URLValidator interface {
	ValidateURL() bool
}

func (o *URL) ValidateURL() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadURL(t navvy.Task, v URLSetter) {
	x, ok := t.(interface {
		URLGetter
		URLValidator
	})
	if !ok {
		return
	}
	if !x.ValidateURL() {
		return
	}

	v.SetURL(x.GetURL())
}

type Zone struct {
	valid bool
	v     string

	l sync.RWMutex
}

type ZoneGetter interface {
	GetZone() string
}

func (o *Zone) GetZone() string {
	o.l.RLock()
	defer o.l.RUnlock()

	if !o.valid {
		panic("Zone value is not valid")
	}
	return o.v
}

type ZoneSetter interface {
	SetZone(string)
}

func (o *Zone) SetZone(v string) {
	o.l.Lock()
	defer o.l.Unlock()

	o.v = v
	o.valid = true
}

type ZoneValidator interface {
	ValidateZone() bool
}

func (o *Zone) ValidateZone() bool {
	o.l.RLock()
	defer o.l.RUnlock()

	return o.valid
}

func LoadZone(t navvy.Task, v ZoneSetter) {
	x, ok := t.(interface {
		ZoneGetter
		ZoneValidator
	})
	if !ok {
		return
	}
	if !x.ValidateZone() {
		return
	}

	v.SetZone(x.GetZone())
}
