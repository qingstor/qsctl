// Code generated by go generate; DO NOT EDIT.
package types

import (
	"fmt"
)
type LocalFileNotExist struct {
	err error
	SourcePath
}

func (f *LocalFileNotExist) Error() string {
	return fmt.Sprintf(`Local file [%s] is not exist: {%v}`, f.GetSourcePath(), f.err)
}

func (f *LocalFileNotExist) Unwrap() error {
	return f.err
}

func NewErrLocalFileNotExist(err error,sourcePath string) error {
	f := &LocalFileNotExist{}
	f.err=err
	f.SetSourcePath(sourcePath)

	return f
}
type LocalFileTooLarge struct {
	err error
	Size
}

func (f *LocalFileTooLarge) Error() string {
	return fmt.Sprintf(`Local file size [%d] is too large`, f.GetSize())
}

func (f *LocalFileTooLarge) Unwrap() error {
	return f.err
}

func NewErrLocalFileTooLarge(err error,size int64) error {
	f := &LocalFileTooLarge{}
	f.err=err
	f.SetSize(size)

	return f
}
type ReadableSizeFormatInvalid struct {
	err error
	ByteSize
}

func (f *ReadableSizeFormatInvalid) Error() string {
	return fmt.Sprintf(`readable size format invalid [%s]`, f.GetByteSize())
}

func (f *ReadableSizeFormatInvalid) Unwrap() error {
	return f.err
}

func NewErrReadableSizeFormatInvalid(err error,byteSize string) error {
	f := &ReadableSizeFormatInvalid{}
	f.err=err
	f.SetByteSize(byteSize)

	return f
}
type StorageBucketInitFailed struct {
	err error
	StorageName
	Zone
}

func (f *StorageBucketInitFailed) Error() string {
	return fmt.Sprintf(`Storage bucket [%s] in zone [%s] initiate failed: {%v}`, f.GetStorageName(), f.GetZone(), f.err)
}

func (f *StorageBucketInitFailed) Unwrap() error {
	return f.err
}

func NewErrStorageBucketInitFailed(err error,storageName string,zone string) error {
	f := &StorageBucketInitFailed{}
	f.err=err
	f.SetStorageName(storageName)
	f.SetZone(zone)

	return f
}
type StorageObjectNoPermission struct {
	err error
	DestinationPath
}

func (f *StorageObjectNoPermission) Error() string {
	return fmt.Sprintf(`Storage Object [%s] do not have enough permission: {%v}`, f.GetDestinationPath(), f.err)
}

func (f *StorageObjectNoPermission) Unwrap() error {
	return f.err
}

func NewErrStorageObjectNoPermission(err error,destinationPath string) error {
	f := &StorageObjectNoPermission{}
	f.err=err
	f.SetDestinationPath(destinationPath)

	return f
}
type StorageObjectNotFound struct {
	err error
	DestinationPath
}

func (f *StorageObjectNotFound) Error() string {
	return fmt.Sprintf(`Storage Object [%s] is not found: {%v}`, f.GetDestinationPath(), f.err)
}

func (f *StorageObjectNotFound) Unwrap() error {
	return f.err
}

func NewErrStorageObjectNotFound(err error,destinationPath string) error {
	f := &StorageObjectNotFound{}
	f.err=err
	f.SetDestinationPath(destinationPath)

	return f
}
type StorageServiceInitFailed struct {
	err error
}

func (f *StorageServiceInitFailed) Error() string {
	return fmt.Sprintf(`Storage service initiate failed: {%v}`, f.err)
}

func (f *StorageServiceInitFailed) Unwrap() error {
	return f.err
}

func NewErrStorageServiceInitFailed(err error) error {
	f := &StorageServiceInitFailed{}
	f.err=err

	return f
}
type Unhandled struct {
	err error
}

func (f *Unhandled) Error() string {
	return fmt.Sprintf(`Operation failed via unhandled error: {%v}`, f.err)
}

func (f *Unhandled) Unwrap() error {
	return f.err
}

func NewErrUnhandled(err error) error {
	f := &Unhandled{}
	f.err=err

	return f
}
type UserInputByteSizeInvalid struct {
	err error
	ByteSize
}

func (f *UserInputByteSizeInvalid) Error() string {
	return fmt.Sprintf(`User input byte size [%s] is invalid: {%v}`, f.GetByteSize(), f.err)
}

func (f *UserInputByteSizeInvalid) Unwrap() error {
	return f.err
}

func NewErrUserInputByteSizeInvalid(err error,byteSize string) error {
	f := &UserInputByteSizeInvalid{}
	f.err=err
	f.SetByteSize(byteSize)

	return f
}
type UserInputDestinationPathInvalid struct {
	err error
	DestinationPath
}

func (f *UserInputDestinationPathInvalid) Error() string {
	return fmt.Sprintf(`User input key [%s] is invalid`, f.GetDestinationPath())
}

func (f *UserInputDestinationPathInvalid) Unwrap() error {
	return f.err
}

func NewErrUserInputDestinationPathInvalid(err error,destinationPath string) error {
	f := &UserInputDestinationPathInvalid{}
	f.err=err
	f.SetDestinationPath(destinationPath)

	return f
}
