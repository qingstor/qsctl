// Code generated by go generate; DO NOT EDIT.
package task

import (
	"fmt"

	"github.com/Xuanwo/navvy"
	"github.com/google/uuid"
	log "github.com/sirupsen/logrus"

	"github.com/yunify/qsctl/v2/pkg/schedule"
	"github.com/yunify/qsctl/v2/pkg/types"
)

var _ navvy.Pool
var _ types.Pool
var _ = uuid.New()

// CopyDirTask will copy a directory recursively between two storager.
type CopyDirTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Output value
}

// NewCopyDir will create a CopyDirTask struct and fetch inherited data from parent task.
func NewCopyDir(task navvy.Task) *CopyDirTask {
	t := &CopyDirTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyDirTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyDir value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyDir value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyDir value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyDir value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyDirTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopyDirTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyDirTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *CopyDirTask) VoidWorkload() {}

// String will implement Stringer interface.
func (t *CopyDirTask) String() string {
	return fmt.Sprintf("CopyDirTask {DestinationPath: %v, DestinationStorage: %v, SourcePath: %v, SourceStorage: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewCopyDirTask will create a CopyDirTask which meets navvy.Task.
func NewCopyDirTask(task navvy.Task) navvy.Task {
	return NewCopyDir(task)
}

// CopyFileTask will copy a file between two storager.
type CopyFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Output value
}

// NewCopyFile will create a CopyFileTask struct and fetch inherited data from parent task.
func NewCopyFile(task navvy.Task) *CopyFileTask {
	t := &CopyFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyFileTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyFile value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyFile value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopyFileTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *CopyFileTask) VoidWorkload() {}

// String will implement Stringer interface.
func (t *CopyFileTask) String() string {
	return fmt.Sprintf("CopyFileTask {DestinationPath: %v, DestinationStorage: %v, SourcePath: %v, SourceStorage: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewCopyFileTask will create a CopyFileTask which meets navvy.Task.
func NewCopyFileTask(task navvy.Task) navvy.Task {
	return NewCopyFile(task)
}

// CopyLargeFileTask will copy a large file between two storager.
type CopyLargeFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage
	types.TotalSize

	// Output value
	types.Offset
	types.PartSize
	types.SegmentID
}

// NewCopyLargeFile will create a CopyLargeFileTask struct and fetch inherited data from parent task.
func NewCopyLargeFile(task navvy.Task) *CopyLargeFileTask {
	t := &CopyLargeFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyLargeFileTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyLargeFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyLargeFile value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyLargeFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyLargeFile value SourceStorage is invalid"))
	}
	if !t.ValidateTotalSize() {
		panic(fmt.Errorf("Task CopyLargeFile value TotalSize is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyLargeFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
	types.LoadTotalSize(task, t)
}

// Run implement navvy.Task
func (t *CopyLargeFileTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyLargeFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *CopyLargeFileTask) VoidWorkload() {}

// String will implement Stringer interface.
func (t *CopyLargeFileTask) String() string {
	return fmt.Sprintf("CopyLargeFileTask {DestinationPath: %v, DestinationStorage: %v, SourcePath: %v, SourceStorage: %v, TotalSize: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSourcePath(), t.GetSourceStorage(), t.GetTotalSize())
}

// NewCopyLargeFileTask will create a CopyLargeFileTask which meets navvy.Task.
func NewCopyLargeFileTask(task navvy.Task) navvy.Task {
	return NewCopyLargeFile(task)
}

// CopyPartialFileTask will copy a partial file to between two storager.
type CopyPartialFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.Offset
	types.PartSize
	types.SegmentID
	types.SourcePath
	types.SourceStorage
	types.TotalSize

	// Output value
	types.Done
	types.Size
}

// NewCopyPartialFile will create a CopyPartialFileTask struct and fetch inherited data from parent task.
func NewCopyPartialFile(task navvy.Task) *CopyPartialFileTask {
	t := &CopyPartialFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyPartialFileTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyPartialFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyPartialFile value DestinationStorage is invalid"))
	}
	if !t.ValidateOffset() {
		panic(fmt.Errorf("Task CopyPartialFile value Offset is invalid"))
	}
	if !t.ValidatePartSize() {
		panic(fmt.Errorf("Task CopyPartialFile value PartSize is invalid"))
	}
	if !t.ValidateSegmentID() {
		panic(fmt.Errorf("Task CopyPartialFile value SegmentID is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyPartialFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyPartialFile value SourceStorage is invalid"))
	}
	if !t.ValidateTotalSize() {
		panic(fmt.Errorf("Task CopyPartialFile value TotalSize is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyPartialFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadOffset(task, t)
	types.LoadPartSize(task, t)
	types.LoadSegmentID(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
	types.LoadTotalSize(task, t)
}

// Run implement navvy.Task
func (t *CopyPartialFileTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyPartialFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *CopyPartialFileTask) VoidWorkload() {}

// String will implement Stringer interface.
func (t *CopyPartialFileTask) String() string {
	return fmt.Sprintf("CopyPartialFileTask {DestinationPath: %v, DestinationStorage: %v, Offset: %v, PartSize: %v, SegmentID: %v, SourcePath: %v, SourceStorage: %v, TotalSize: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetOffset(), t.GetPartSize(), t.GetSegmentID(), t.GetSourcePath(), t.GetSourceStorage(), t.GetTotalSize())
}

// NewCopyPartialFileTask will create a CopyPartialFileTask which meets navvy.Task.
func NewCopyPartialFileTask(task navvy.Task) navvy.Task {
	return NewCopyPartialFile(task)
}

// CopyPartialStreamTask will copy a partial stream between two storager.
type CopyPartialStreamTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.BytesPool
	types.DestinationPath
	types.DestinationStorage
	types.PartSize
	types.SegmentID
	types.SourcePath
	types.SourceStorage

	// Output value
	types.Content
	types.Done
	types.Size
}

// NewCopyPartialStream will create a CopyPartialStreamTask struct and fetch inherited data from parent task.
func NewCopyPartialStream(task navvy.Task) *CopyPartialStreamTask {
	t := &CopyPartialStreamTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyPartialStreamTask) validateInput() {
	if !t.ValidateBytesPool() {
		panic(fmt.Errorf("Task CopyPartialStream value BytesPool is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyPartialStream value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyPartialStream value DestinationStorage is invalid"))
	}
	if !t.ValidatePartSize() {
		panic(fmt.Errorf("Task CopyPartialStream value PartSize is invalid"))
	}
	if !t.ValidateSegmentID() {
		panic(fmt.Errorf("Task CopyPartialStream value SegmentID is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyPartialStream value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyPartialStream value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyPartialStreamTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadBytesPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadPartSize(task, t)
	types.LoadSegmentID(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopyPartialStreamTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyPartialStreamTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *CopyPartialStreamTask) VoidWorkload() {}

// String will implement Stringer interface.
func (t *CopyPartialStreamTask) String() string {
	return fmt.Sprintf("CopyPartialStreamTask {BytesPool: %v, DestinationPath: %v, DestinationStorage: %v, PartSize: %v, SegmentID: %v, SourcePath: %v, SourceStorage: %v}", t.GetBytesPool(), t.GetDestinationPath(), t.GetDestinationStorage(), t.GetPartSize(), t.GetSegmentID(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewCopyPartialStreamTask will create a CopyPartialStreamTask which meets navvy.Task.
func NewCopyPartialStreamTask(task navvy.Task) navvy.Task {
	return NewCopyPartialStream(task)
}

// CopySingleFileTask will execute a file copy operation between towo storager.
type CopySingleFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.MD5Sum
	types.Size
	types.SourcePath
	types.SourceStorage

	// Output value
}

// NewCopySingleFile will create a CopySingleFileTask struct and fetch inherited data from parent task.
func NewCopySingleFile(task navvy.Task) *CopySingleFileTask {
	t := &CopySingleFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopySingleFileTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopySingleFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopySingleFile value DestinationStorage is invalid"))
	}
	if !t.ValidateMD5Sum() {
		panic(fmt.Errorf("Task CopySingleFile value MD5Sum is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task CopySingleFile value Size is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopySingleFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopySingleFile value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopySingleFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadMD5Sum(task, t)
	types.LoadSize(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopySingleFileTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopySingleFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *CopySingleFileTask) VoidWorkload() {}

// String will implement Stringer interface.
func (t *CopySingleFileTask) String() string {
	return fmt.Sprintf("CopySingleFileTask {DestinationPath: %v, DestinationStorage: %v, MD5Sum: %v, Size: %v, SourcePath: %v, SourceStorage: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetMD5Sum(), t.GetSize(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewCopySingleFileTask will create a CopySingleFileTask which meets navvy.Task.
func NewCopySingleFileTask(task navvy.Task) navvy.Task {
	return NewCopySingleFile(task)
}

// CopySmallFileTask will copy a small file between two storager.
type CopySmallFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.Size
	types.SourcePath
	types.SourceStorage

	// Output value
	types.MD5Sum
}

// NewCopySmallFile will create a CopySmallFileTask struct and fetch inherited data from parent task.
func NewCopySmallFile(task navvy.Task) *CopySmallFileTask {
	t := &CopySmallFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopySmallFileTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopySmallFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopySmallFile value DestinationStorage is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task CopySmallFile value Size is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopySmallFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopySmallFile value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopySmallFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSize(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopySmallFileTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopySmallFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *CopySmallFileTask) VoidWorkload() {}

// String will implement Stringer interface.
func (t *CopySmallFileTask) String() string {
	return fmt.Sprintf("CopySmallFileTask {DestinationPath: %v, DestinationStorage: %v, Size: %v, SourcePath: %v, SourceStorage: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSize(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewCopySmallFileTask will create a CopySmallFileTask which meets navvy.Task.
func NewCopySmallFileTask(task navvy.Task) navvy.Task {
	return NewCopySmallFile(task)
}

// CopyStreamTask will copy a stream between two storager.
type CopyStreamTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Output value
	types.BytesPool
	types.PartSize
	types.SegmentID
}

// NewCopyStream will create a CopyStreamTask struct and fetch inherited data from parent task.
func NewCopyStream(task navvy.Task) *CopyStreamTask {
	t := &CopyStreamTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyStreamTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyStream value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyStream value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyStream value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyStream value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyStreamTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopyStreamTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyStreamTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *CopyStreamTask) VoidWorkload() {}

// String will implement Stringer interface.
func (t *CopyStreamTask) String() string {
	return fmt.Sprintf("CopyStreamTask {DestinationPath: %v, DestinationStorage: %v, SourcePath: %v, SourceStorage: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewCopyStreamTask will create a CopyStreamTask which meets navvy.Task.
func NewCopyStreamTask(task navvy.Task) navvy.Task {
	return NewCopyStream(task)
}

// CreateStorageTask will create a storage.
type CreateStorageTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Service

	// Output value
	types.StorageName
	types.Zone
}

// NewCreateStorage will create a CreateStorageTask struct and fetch inherited data from parent task.
func NewCreateStorage(task navvy.Task) *CreateStorageTask {
	t := &CreateStorageTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CreateStorageTask) validateInput() {
	if !t.ValidateService() {
		panic(fmt.Errorf("Task CreateStorage value Service is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CreateStorageTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadService(task, t)
}

// Run implement navvy.Task
func (t *CreateStorageTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *CreateStorageTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *CreateStorageTask) IOWorkload() {}

// String will implement Stringer interface.
func (t *CreateStorageTask) String() string {
	return fmt.Sprintf("CreateStorageTask {Service: %v}", t.GetService())
}

// NewCreateStorageTask will create a CreateStorageTask which meets navvy.Task.
func NewCreateStorageTask(task navvy.Task) navvy.Task {
	return NewCreateStorage(task)
}

// DeleteDirTask will will delete a dir recursively.
type DeleteDirTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Path
	types.Storage

	// Output value
}

// NewDeleteDir will create a DeleteDirTask struct and fetch inherited data from parent task.
func NewDeleteDir(task navvy.Task) *DeleteDirTask {
	t := &DeleteDirTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeleteDirTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task DeleteDir value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task DeleteDir value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeleteDirTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *DeleteDirTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeleteDirTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *DeleteDirTask) VoidWorkload() {}

// String will implement Stringer interface.
func (t *DeleteDirTask) String() string {
	return fmt.Sprintf("DeleteDirTask {Path: %v, Storage: %v}", t.GetPath(), t.GetStorage())
}

// NewDeleteDirTask will create a DeleteDirTask which meets navvy.Task.
func NewDeleteDirTask(task navvy.Task) navvy.Task {
	return NewDeleteDir(task)
}

// DeleteFileTask will will delete a file from storage.
type DeleteFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Path
	types.Storage

	// Output value
}

// NewDeleteFile will create a DeleteFileTask struct and fetch inherited data from parent task.
func NewDeleteFile(task navvy.Task) *DeleteFileTask {
	t := &DeleteFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeleteFileTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task DeleteFile value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task DeleteFile value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeleteFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *DeleteFileTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeleteFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *DeleteFileTask) IOWorkload() {}

// String will implement Stringer interface.
func (t *DeleteFileTask) String() string {
	return fmt.Sprintf("DeleteFileTask {Path: %v, Storage: %v}", t.GetPath(), t.GetStorage())
}

// NewDeleteFileTask will create a DeleteFileTask which meets navvy.Task.
func NewDeleteFileTask(task navvy.Task) navvy.Task {
	return NewDeleteFile(task)
}

// DeleteSegmentTask will delete all segments with a given path.
type DeleteSegmentTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.SegmentID
	types.Storage

	// Output value
}

// NewDeleteSegment will create a DeleteSegmentTask struct and fetch inherited data from parent task.
func NewDeleteSegment(task navvy.Task) *DeleteSegmentTask {
	t := &DeleteSegmentTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeleteSegmentTask) validateInput() {
	if !t.ValidateSegmentID() {
		panic(fmt.Errorf("Task DeleteSegment value SegmentID is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task DeleteSegment value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeleteSegmentTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadSegmentID(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *DeleteSegmentTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeleteSegmentTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *DeleteSegmentTask) IOWorkload() {}

// String will implement Stringer interface.
func (t *DeleteSegmentTask) String() string {
	return fmt.Sprintf("DeleteSegmentTask {SegmentID: %v, Storage: %v}", t.GetSegmentID(), t.GetStorage())
}

// NewDeleteSegmentTask will create a DeleteSegmentTask which meets navvy.Task.
func NewDeleteSegmentTask(task navvy.Task) navvy.Task {
	return NewDeleteSegment(task)
}

// DeleteSegmentDirTask will delete all segments under a path.
type DeleteSegmentDirTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Path
	types.Storage

	// Output value
}

// NewDeleteSegmentDir will create a DeleteSegmentDirTask struct and fetch inherited data from parent task.
func NewDeleteSegmentDir(task navvy.Task) *DeleteSegmentDirTask {
	t := &DeleteSegmentDirTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeleteSegmentDirTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task DeleteSegmentDir value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task DeleteSegmentDir value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeleteSegmentDirTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *DeleteSegmentDirTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeleteSegmentDirTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *DeleteSegmentDirTask) VoidWorkload() {}

// String will implement Stringer interface.
func (t *DeleteSegmentDirTask) String() string {
	return fmt.Sprintf("DeleteSegmentDirTask {Path: %v, Storage: %v}", t.GetPath(), t.GetStorage())
}

// NewDeleteSegmentDirTask will create a DeleteSegmentDirTask which meets navvy.Task.
func NewDeleteSegmentDirTask(task navvy.Task) navvy.Task {
	return NewDeleteSegmentDir(task)
}

// DeleteStorageTask will delete a storage.
type DeleteStorageTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Force
	types.Service
	types.StorageName

	// Output value
}

// NewDeleteStorage will create a DeleteStorageTask struct and fetch inherited data from parent task.
func NewDeleteStorage(task navvy.Task) *DeleteStorageTask {
	t := &DeleteStorageTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeleteStorageTask) validateInput() {
	if !t.ValidateForce() {
		panic(fmt.Errorf("Task DeleteStorage value Force is invalid"))
	}
	if !t.ValidateService() {
		panic(fmt.Errorf("Task DeleteStorage value Service is invalid"))
	}
	if !t.ValidateStorageName() {
		panic(fmt.Errorf("Task DeleteStorage value StorageName is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeleteStorageTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadForce(task, t)
	types.LoadService(task, t)
	types.LoadStorageName(task, t)
}

// Run implement navvy.Task
func (t *DeleteStorageTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeleteStorageTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *DeleteStorageTask) IOWorkload() {}

// String will implement Stringer interface.
func (t *DeleteStorageTask) String() string {
	return fmt.Sprintf("DeleteStorageTask {Force: %v, Service: %v, StorageName: %v}", t.GetForce(), t.GetService(), t.GetStorageName())
}

// NewDeleteStorageTask will create a DeleteStorageTask which meets navvy.Task.
func NewDeleteStorageTask(task navvy.Task) navvy.Task {
	return NewDeleteStorage(task)
}

// IterateFileTask will iterate file and execute operations on it.
type IterateFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Path
	types.PathFunc
	types.Recursive
	types.Storage

	// Output value
}

// NewIterateFile will create a IterateFileTask struct and fetch inherited data from parent task.
func NewIterateFile(task navvy.Task) *IterateFileTask {
	t := &IterateFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *IterateFileTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task IterateFile value Path is invalid"))
	}
	if !t.ValidatePathFunc() {
		panic(fmt.Errorf("Task IterateFile value PathFunc is invalid"))
	}
	if !t.ValidateRecursive() {
		panic(fmt.Errorf("Task IterateFile value Recursive is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task IterateFile value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *IterateFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadPathFunc(task, t)
	types.LoadRecursive(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *IterateFileTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *IterateFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *IterateFileTask) VoidWorkload() {}

// String will implement Stringer interface.
func (t *IterateFileTask) String() string {
	return fmt.Sprintf("IterateFileTask {Path: %v, Recursive: %v, Storage: %v}", t.GetPath(), t.GetRecursive(), t.GetStorage())
}

// NewIterateFileTask will create a IterateFileTask which meets navvy.Task.
func NewIterateFileTask(task navvy.Task) navvy.Task {
	return NewIterateFile(task)
}

// IterateSegmentTask will iterate segment and execute operations on it.
type IterateSegmentTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Path
	types.SegmentIDFunc
	types.Storage

	// Output value
}

// NewIterateSegment will create a IterateSegmentTask struct and fetch inherited data from parent task.
func NewIterateSegment(task navvy.Task) *IterateSegmentTask {
	t := &IterateSegmentTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *IterateSegmentTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task IterateSegment value Path is invalid"))
	}
	if !t.ValidateSegmentIDFunc() {
		panic(fmt.Errorf("Task IterateSegment value SegmentIDFunc is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task IterateSegment value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *IterateSegmentTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadSegmentIDFunc(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *IterateSegmentTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *IterateSegmentTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *IterateSegmentTask) VoidWorkload() {}

// String will implement Stringer interface.
func (t *IterateSegmentTask) String() string {
	return fmt.Sprintf("IterateSegmentTask {Path: %v, Storage: %v}", t.GetPath(), t.GetStorage())
}

// NewIterateSegmentTask will create a IterateSegmentTask which meets navvy.Task.
func NewIterateSegmentTask(task navvy.Task) navvy.Task {
	return NewIterateSegment(task)
}

// ListFileTask will list files.
type ListFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Path
	types.Recursive
	types.Storage

	// Output value
	types.ObjectChannel
}

// NewListFile will create a ListFileTask struct and fetch inherited data from parent task.
func NewListFile(task navvy.Task) *ListFileTask {
	t := &ListFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ListFileTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task ListFile value Path is invalid"))
	}
	if !t.ValidateRecursive() {
		panic(fmt.Errorf("Task ListFile value Recursive is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task ListFile value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ListFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadRecursive(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *ListFileTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *ListFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *ListFileTask) VoidWorkload() {}

// String will implement Stringer interface.
func (t *ListFileTask) String() string {
	return fmt.Sprintf("ListFileTask {Path: %v, Recursive: %v, Storage: %v}", t.GetPath(), t.GetRecursive(), t.GetStorage())
}

// NewListFileTask will create a ListFileTask which meets navvy.Task.
func NewListFileTask(task navvy.Task) navvy.Task {
	return NewListFile(task)
}

// ListSegmentTask will list segments.
type ListSegmentTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Path
	types.Storage

	// Output value
	types.SegmentChannel
}

// NewListSegment will create a ListSegmentTask struct and fetch inherited data from parent task.
func NewListSegment(task navvy.Task) *ListSegmentTask {
	t := &ListSegmentTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ListSegmentTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task ListSegment value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task ListSegment value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ListSegmentTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *ListSegmentTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *ListSegmentTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *ListSegmentTask) VoidWorkload() {}

// String will implement Stringer interface.
func (t *ListSegmentTask) String() string {
	return fmt.Sprintf("ListSegmentTask {Path: %v, Storage: %v}", t.GetPath(), t.GetStorage())
}

// NewListSegmentTask will create a ListSegmentTask which meets navvy.Task.
func NewListSegmentTask(task navvy.Task) navvy.Task {
	return NewListSegment(task)
}

// ListStorageTask will send get request to get bucket list.
type ListStorageTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Service

	// Output value
	types.BucketList
	types.Zone
}

// NewListStorage will create a ListStorageTask struct and fetch inherited data from parent task.
func NewListStorage(task navvy.Task) *ListStorageTask {
	t := &ListStorageTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ListStorageTask) validateInput() {
	if !t.ValidateService() {
		panic(fmt.Errorf("Task ListStorage value Service is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ListStorageTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadService(task, t)
}

// Run implement navvy.Task
func (t *ListStorageTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *ListStorageTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *ListStorageTask) VoidWorkload() {}

// String will implement Stringer interface.
func (t *ListStorageTask) String() string {
	return fmt.Sprintf("ListStorageTask {Service: %v}", t.GetService())
}

// NewListStorageTask will create a ListStorageTask which meets navvy.Task.
func NewListStorageTask(task navvy.Task) navvy.Task {
	return NewListStorage(task)
}

// MD5SumFileTask will get file's md5 sum.
type MD5SumFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Offset
	types.Path
	types.Size
	types.Storage

	// Output value
	types.MD5Sum
}

// NewMD5SumFile will create a MD5SumFileTask struct and fetch inherited data from parent task.
func NewMD5SumFile(task navvy.Task) *MD5SumFileTask {
	t := &MD5SumFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *MD5SumFileTask) validateInput() {
	if !t.ValidateOffset() {
		panic(fmt.Errorf("Task MD5SumFile value Offset is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task MD5SumFile value Path is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task MD5SumFile value Size is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task MD5SumFile value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *MD5SumFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadOffset(task, t)
	types.LoadPath(task, t)
	types.LoadSize(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *MD5SumFileTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *MD5SumFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *MD5SumFileTask) IOWorkload() {}

// String will implement Stringer interface.
func (t *MD5SumFileTask) String() string {
	return fmt.Sprintf("MD5SumFileTask {Offset: %v, Path: %v, Size: %v, Storage: %v}", t.GetOffset(), t.GetPath(), t.GetSize(), t.GetStorage())
}

// NewMD5SumFileTask will create a MD5SumFileTask which meets navvy.Task.
func NewMD5SumFileTask(task navvy.Task) navvy.Task {
	return NewMD5SumFile(task)
}

// MD5SumStreamTask will get stream's md5 sum.
type MD5SumStreamTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Content

	// Output value
	types.MD5Sum
}

// NewMD5SumStream will create a MD5SumStreamTask struct and fetch inherited data from parent task.
func NewMD5SumStream(task navvy.Task) *MD5SumStreamTask {
	t := &MD5SumStreamTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *MD5SumStreamTask) validateInput() {
	if !t.ValidateContent() {
		panic(fmt.Errorf("Task MD5SumStream value Content is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *MD5SumStreamTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadContent(task, t)
}

// Run implement navvy.Task
func (t *MD5SumStreamTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *MD5SumStreamTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *MD5SumStreamTask) IOWorkload() {}

// String will implement Stringer interface.
func (t *MD5SumStreamTask) String() string {
	return fmt.Sprintf("MD5SumStreamTask {Content: %v}", t.GetContent())
}

// NewMD5SumStreamTask will create a MD5SumStreamTask which meets navvy.Task.
func NewMD5SumStreamTask(task navvy.Task) navvy.Task {
	return NewMD5SumStream(task)
}

// MoveDirTask will move a directory recursively between two storager.
type MoveDirTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Output value
}

// NewMoveDir will create a MoveDirTask struct and fetch inherited data from parent task.
func NewMoveDir(task navvy.Task) *MoveDirTask {
	t := &MoveDirTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *MoveDirTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task MoveDir value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task MoveDir value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task MoveDir value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task MoveDir value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *MoveDirTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *MoveDirTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *MoveDirTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *MoveDirTask) VoidWorkload() {}

// String will implement Stringer interface.
func (t *MoveDirTask) String() string {
	return fmt.Sprintf("MoveDirTask {DestinationPath: %v, DestinationStorage: %v, SourcePath: %v, SourceStorage: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewMoveDirTask will create a MoveDirTask which meets navvy.Task.
func NewMoveDirTask(task navvy.Task) navvy.Task {
	return NewMoveDir(task)
}

// MoveFileTask will move a file between two storager.
type MoveFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Output value
}

// NewMoveFile will create a MoveFileTask struct and fetch inherited data from parent task.
func NewMoveFile(task navvy.Task) *MoveFileTask {
	t := &MoveFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *MoveFileTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task MoveFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task MoveFile value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task MoveFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task MoveFile value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *MoveFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *MoveFileTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *MoveFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *MoveFileTask) VoidWorkload() {}

// String will implement Stringer interface.
func (t *MoveFileTask) String() string {
	return fmt.Sprintf("MoveFileTask {DestinationPath: %v, DestinationStorage: %v, SourcePath: %v, SourceStorage: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewMoveFileTask will create a MoveFileTask which meets navvy.Task.
func NewMoveFileTask(task navvy.Task) navvy.Task {
	return NewMoveFile(task)
}

// ReachFileTask will will reach a remote object and return the signed url.
type ReachFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Expire
	types.Path
	types.Storage

	// Output value
	types.URL
}

// NewReachFile will create a ReachFileTask struct and fetch inherited data from parent task.
func NewReachFile(task navvy.Task) *ReachFileTask {
	t := &ReachFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ReachFileTask) validateInput() {
	if !t.ValidateExpire() {
		panic(fmt.Errorf("Task ReachFile value Expire is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task ReachFile value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task ReachFile value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ReachFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadExpire(task, t)
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *ReachFileTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *ReachFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *ReachFileTask) IOWorkload() {}

// String will implement Stringer interface.
func (t *ReachFileTask) String() string {
	return fmt.Sprintf("ReachFileTask {Expire: %v, Path: %v, Storage: %v}", t.GetExpire(), t.GetPath(), t.GetStorage())
}

// NewReachFileTask will create a ReachFileTask which meets navvy.Task.
func NewReachFileTask(task navvy.Task) navvy.Task {
	return NewReachFile(task)
}

// SegmentAbortAllTask will abort all multipart uploads in a bucket.
type SegmentAbortAllTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Storage
	types.StorageName

	// Output value
}

// NewSegmentAbortAll will create a SegmentAbortAllTask struct and fetch inherited data from parent task.
func NewSegmentAbortAll(task navvy.Task) *SegmentAbortAllTask {
	t := &SegmentAbortAllTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SegmentAbortAllTask) validateInput() {
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task SegmentAbortAll value Storage is invalid"))
	}
	if !t.ValidateStorageName() {
		panic(fmt.Errorf("Task SegmentAbortAll value StorageName is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SegmentAbortAllTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadStorage(task, t)
	types.LoadStorageName(task, t)
}

// Run implement navvy.Task
func (t *SegmentAbortAllTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *SegmentAbortAllTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *SegmentAbortAllTask) VoidWorkload() {}

// String will implement Stringer interface.
func (t *SegmentAbortAllTask) String() string {
	return fmt.Sprintf("SegmentAbortAllTask {Storage: %v, StorageName: %v}", t.GetStorage(), t.GetStorageName())
}

// NewSegmentAbortAllTask will create a SegmentAbortAllTask which meets navvy.Task.
func NewSegmentAbortAllTask(task navvy.Task) navvy.Task {
	return NewSegmentAbortAll(task)
}

// SegmentCompleteTask will complete a segment.
type SegmentCompleteTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Path
	types.SegmentID
	types.Storage

	// Output value
}

// NewSegmentComplete will create a SegmentCompleteTask struct and fetch inherited data from parent task.
func NewSegmentComplete(task navvy.Task) *SegmentCompleteTask {
	t := &SegmentCompleteTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SegmentCompleteTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task SegmentComplete value Path is invalid"))
	}
	if !t.ValidateSegmentID() {
		panic(fmt.Errorf("Task SegmentComplete value SegmentID is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task SegmentComplete value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SegmentCompleteTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadSegmentID(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *SegmentCompleteTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *SegmentCompleteTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *SegmentCompleteTask) IOWorkload() {}

// String will implement Stringer interface.
func (t *SegmentCompleteTask) String() string {
	return fmt.Sprintf("SegmentCompleteTask {Path: %v, SegmentID: %v, Storage: %v}", t.GetPath(), t.GetSegmentID(), t.GetStorage())
}

// NewSegmentCompleteTask will create a SegmentCompleteTask which meets navvy.Task.
func NewSegmentCompleteTask(task navvy.Task) navvy.Task {
	return NewSegmentComplete(task)
}

// SegmentFileCopyTask will copy a segment file.
type SegmentFileCopyTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.MD5Sum
	types.Offset
	types.SegmentID
	types.Size
	types.SourcePath
	types.SourceStorage

	// Output value
}

// NewSegmentFileCopy will create a SegmentFileCopyTask struct and fetch inherited data from parent task.
func NewSegmentFileCopy(task navvy.Task) *SegmentFileCopyTask {
	t := &SegmentFileCopyTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SegmentFileCopyTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task SegmentFileCopy value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task SegmentFileCopy value DestinationStorage is invalid"))
	}
	if !t.ValidateMD5Sum() {
		panic(fmt.Errorf("Task SegmentFileCopy value MD5Sum is invalid"))
	}
	if !t.ValidateOffset() {
		panic(fmt.Errorf("Task SegmentFileCopy value Offset is invalid"))
	}
	if !t.ValidateSegmentID() {
		panic(fmt.Errorf("Task SegmentFileCopy value SegmentID is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task SegmentFileCopy value Size is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task SegmentFileCopy value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task SegmentFileCopy value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SegmentFileCopyTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadMD5Sum(task, t)
	types.LoadOffset(task, t)
	types.LoadSegmentID(task, t)
	types.LoadSize(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *SegmentFileCopyTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *SegmentFileCopyTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *SegmentFileCopyTask) IOWorkload() {}

// String will implement Stringer interface.
func (t *SegmentFileCopyTask) String() string {
	return fmt.Sprintf("SegmentFileCopyTask {DestinationPath: %v, DestinationStorage: %v, MD5Sum: %v, Offset: %v, SegmentID: %v, Size: %v, SourcePath: %v, SourceStorage: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetMD5Sum(), t.GetOffset(), t.GetSegmentID(), t.GetSize(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewSegmentFileCopyTask will create a SegmentFileCopyTask which meets navvy.Task.
func NewSegmentFileCopyTask(task navvy.Task) navvy.Task {
	return NewSegmentFileCopy(task)
}

// SegmentInitTask will init a segment upload.
type SegmentInitTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.PartSize
	types.Path
	types.Storage

	// Output value
	types.SegmentID
}

// NewSegmentInit will create a SegmentInitTask struct and fetch inherited data from parent task.
func NewSegmentInit(task navvy.Task) *SegmentInitTask {
	t := &SegmentInitTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SegmentInitTask) validateInput() {
	if !t.ValidatePartSize() {
		panic(fmt.Errorf("Task SegmentInit value PartSize is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task SegmentInit value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task SegmentInit value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SegmentInitTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPartSize(task, t)
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *SegmentInitTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *SegmentInitTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *SegmentInitTask) IOWorkload() {}

// String will implement Stringer interface.
func (t *SegmentInitTask) String() string {
	return fmt.Sprintf("SegmentInitTask {PartSize: %v, Path: %v, Storage: %v}", t.GetPartSize(), t.GetPath(), t.GetStorage())
}

// NewSegmentInitTask will create a SegmentInitTask which meets navvy.Task.
func NewSegmentInitTask(task navvy.Task) navvy.Task {
	return NewSegmentInit(task)
}

// SegmentStreamCopyTask will copy a segment stream.
type SegmentStreamCopyTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Content
	types.DestinationPath
	types.DestinationStorage
	types.MD5Sum
	types.Offset
	types.SegmentID
	types.Size

	// Output value
}

// NewSegmentStreamCopy will create a SegmentStreamCopyTask struct and fetch inherited data from parent task.
func NewSegmentStreamCopy(task navvy.Task) *SegmentStreamCopyTask {
	t := &SegmentStreamCopyTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SegmentStreamCopyTask) validateInput() {
	if !t.ValidateContent() {
		panic(fmt.Errorf("Task SegmentStreamCopy value Content is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task SegmentStreamCopy value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task SegmentStreamCopy value DestinationStorage is invalid"))
	}
	if !t.ValidateMD5Sum() {
		panic(fmt.Errorf("Task SegmentStreamCopy value MD5Sum is invalid"))
	}
	if !t.ValidateOffset() {
		panic(fmt.Errorf("Task SegmentStreamCopy value Offset is invalid"))
	}
	if !t.ValidateSegmentID() {
		panic(fmt.Errorf("Task SegmentStreamCopy value SegmentID is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task SegmentStreamCopy value Size is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SegmentStreamCopyTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadContent(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadMD5Sum(task, t)
	types.LoadOffset(task, t)
	types.LoadSegmentID(task, t)
	types.LoadSize(task, t)
}

// Run implement navvy.Task
func (t *SegmentStreamCopyTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *SegmentStreamCopyTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *SegmentStreamCopyTask) IOWorkload() {}

// String will implement Stringer interface.
func (t *SegmentStreamCopyTask) String() string {
	return fmt.Sprintf("SegmentStreamCopyTask {Content: %v, DestinationPath: %v, DestinationStorage: %v, MD5Sum: %v, Offset: %v, SegmentID: %v, Size: %v}", t.GetContent(), t.GetDestinationPath(), t.GetDestinationStorage(), t.GetMD5Sum(), t.GetOffset(), t.GetSegmentID(), t.GetSize())
}

// NewSegmentStreamCopyTask will create a SegmentStreamCopyTask which meets navvy.Task.
func NewSegmentStreamCopyTask(task navvy.Task) navvy.Task {
	return NewSegmentStreamCopy(task)
}

// StatFileTask will stat a remote object by request headObject.
type StatFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Path
	types.Storage

	// Output value
	types.Object
}

// NewStatFile will create a StatFileTask struct and fetch inherited data from parent task.
func NewStatFile(task navvy.Task) *StatFileTask {
	t := &StatFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *StatFileTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task StatFile value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task StatFile value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *StatFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *StatFileTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *StatFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *StatFileTask) IOWorkload() {}

// String will implement Stringer interface.
func (t *StatFileTask) String() string {
	return fmt.Sprintf("StatFileTask {Path: %v, Storage: %v}", t.GetPath(), t.GetStorage())
}

// NewStatFileTask will create a StatFileTask which meets navvy.Task.
func NewStatFileTask(task navvy.Task) navvy.Task {
	return NewStatFile(task)
}

// SyncTask will sync directory between two storage.
type SyncTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Output value
}

// NewSync will create a SyncTask struct and fetch inherited data from parent task.
func NewSync(task navvy.Task) *SyncTask {
	t := &SyncTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SyncTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task Sync value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task Sync value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task Sync value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task Sync value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SyncTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *SyncTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *SyncTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

func (t *SyncTask) VoidWorkload() {}

// String will implement Stringer interface.
func (t *SyncTask) String() string {
	return fmt.Sprintf("SyncTask {DestinationPath: %v, DestinationStorage: %v, SourcePath: %v, SourceStorage: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewSyncTask will create a SyncTask which meets navvy.Task.
func NewSyncTask(task navvy.Task) navvy.Task {
	return NewSync(task)
}
