// Code generated by go generate; DO NOT EDIT.
package task

import (
	"fmt"

	"github.com/Xuanwo/navvy"
	"github.com/google/uuid"
	log "github.com/sirupsen/logrus"

	"github.com/yunify/qsctl/v2/pkg/schedule"
	"github.com/yunify/qsctl/v2/pkg/types"
)

var _ navvy.Pool
var _ types.Pool
var _ = uuid.New()

// CopyDirTask will copy a directory recursively between two storager.
type CopyDirTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Output value
}

// NewCopyDir will create a CopyDirTask struct and fetch inherited data from parent task.
func NewCopyDir(task navvy.Task) *CopyDirTask {
	t := &CopyDirTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyDirTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyDir value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyDir value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyDir value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyDir value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyDirTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopyDirTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyDirTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyDirTask) String() string {
	return fmt.Sprintf("CopyDirTask {DestinationPath: %v, DestinationStorage: %v, SourcePath: %v, SourceStorage: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewCopyDirTask will create a CopyDirTask which meets navvy.Task.
func NewCopyDirTask(task navvy.Task) navvy.Task {
	return NewCopyDir(task)
}

// CopyFileTask will copy a file between two storager.
type CopyFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.CheckTasks
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Output value
}

// NewCopyFile will create a CopyFileTask struct and fetch inherited data from parent task.
func NewCopyFile(task navvy.Task) *CopyFileTask {
	t := &CopyFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyFileTask) validateInput() {
	if !t.ValidateCheckTasks() {
		panic(fmt.Errorf("Task CopyFile value CheckTasks is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyFile value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyFile value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadCheckTasks(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopyFileTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyFileTask) String() string {
	return fmt.Sprintf("CopyFileTask {CheckTasks: %v, DestinationPath: %v, DestinationStorage: %v, SourcePath: %v, SourceStorage: %v}", t.GetCheckTasks(), t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewCopyFileTask will create a CopyFileTask which meets navvy.Task.
func NewCopyFileTask(task navvy.Task) navvy.Task {
	return NewCopyFile(task)
}

// CopyLargeFileTask will copy a large file between two storager.
type CopyLargeFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage
	types.TotalSize

	// Output value
	types.Offset
	types.PartSize
	types.SegmentID
}

// NewCopyLargeFile will create a CopyLargeFileTask struct and fetch inherited data from parent task.
func NewCopyLargeFile(task navvy.Task) *CopyLargeFileTask {
	t := &CopyLargeFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyLargeFileTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyLargeFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyLargeFile value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyLargeFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyLargeFile value SourceStorage is invalid"))
	}
	if !t.ValidateTotalSize() {
		panic(fmt.Errorf("Task CopyLargeFile value TotalSize is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyLargeFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
	types.LoadTotalSize(task, t)
}

// Run implement navvy.Task
func (t *CopyLargeFileTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyLargeFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyLargeFileTask) String() string {
	return fmt.Sprintf("CopyLargeFileTask {DestinationPath: %v, DestinationStorage: %v, SourcePath: %v, SourceStorage: %v, TotalSize: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSourcePath(), t.GetSourceStorage(), t.GetTotalSize())
}

// NewCopyLargeFileTask will create a CopyLargeFileTask which meets navvy.Task.
func NewCopyLargeFileTask(task navvy.Task) navvy.Task {
	return NewCopyLargeFile(task)
}

// CopyPartialFileTask will copy a partial file to between two storager.
type CopyPartialFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.Offset
	types.PartSize
	types.SegmentID
	types.SourcePath
	types.SourceStorage
	types.TotalSize

	// Output value
	types.Done
	types.Size
}

// NewCopyPartialFile will create a CopyPartialFileTask struct and fetch inherited data from parent task.
func NewCopyPartialFile(task navvy.Task) *CopyPartialFileTask {
	t := &CopyPartialFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyPartialFileTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyPartialFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyPartialFile value DestinationStorage is invalid"))
	}
	if !t.ValidateOffset() {
		panic(fmt.Errorf("Task CopyPartialFile value Offset is invalid"))
	}
	if !t.ValidatePartSize() {
		panic(fmt.Errorf("Task CopyPartialFile value PartSize is invalid"))
	}
	if !t.ValidateSegmentID() {
		panic(fmt.Errorf("Task CopyPartialFile value SegmentID is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyPartialFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyPartialFile value SourceStorage is invalid"))
	}
	if !t.ValidateTotalSize() {
		panic(fmt.Errorf("Task CopyPartialFile value TotalSize is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyPartialFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadOffset(task, t)
	types.LoadPartSize(task, t)
	types.LoadSegmentID(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
	types.LoadTotalSize(task, t)
}

// Run implement navvy.Task
func (t *CopyPartialFileTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyPartialFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyPartialFileTask) String() string {
	return fmt.Sprintf("CopyPartialFileTask {DestinationPath: %v, DestinationStorage: %v, Offset: %v, PartSize: %v, SegmentID: %v, SourcePath: %v, SourceStorage: %v, TotalSize: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetOffset(), t.GetPartSize(), t.GetSegmentID(), t.GetSourcePath(), t.GetSourceStorage(), t.GetTotalSize())
}

// NewCopyPartialFileTask will create a CopyPartialFileTask which meets navvy.Task.
func NewCopyPartialFileTask(task navvy.Task) navvy.Task {
	return NewCopyPartialFile(task)
}

// CopyPartialStreamTask will copy a partial stream between two storager.
type CopyPartialStreamTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.BytesPool
	types.DestinationPath
	types.DestinationStorage
	types.PartSize
	types.SegmentID
	types.SourcePath
	types.SourceStorage

	// Output value
	types.Content
	types.Done
	types.Size
}

// NewCopyPartialStream will create a CopyPartialStreamTask struct and fetch inherited data from parent task.
func NewCopyPartialStream(task navvy.Task) *CopyPartialStreamTask {
	t := &CopyPartialStreamTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyPartialStreamTask) validateInput() {
	if !t.ValidateBytesPool() {
		panic(fmt.Errorf("Task CopyPartialStream value BytesPool is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyPartialStream value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyPartialStream value DestinationStorage is invalid"))
	}
	if !t.ValidatePartSize() {
		panic(fmt.Errorf("Task CopyPartialStream value PartSize is invalid"))
	}
	if !t.ValidateSegmentID() {
		panic(fmt.Errorf("Task CopyPartialStream value SegmentID is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyPartialStream value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyPartialStream value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyPartialStreamTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadBytesPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadPartSize(task, t)
	types.LoadSegmentID(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopyPartialStreamTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyPartialStreamTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyPartialStreamTask) String() string {
	return fmt.Sprintf("CopyPartialStreamTask {BytesPool: %v, DestinationPath: %v, DestinationStorage: %v, PartSize: %v, SegmentID: %v, SourcePath: %v, SourceStorage: %v}", t.GetBytesPool(), t.GetDestinationPath(), t.GetDestinationStorage(), t.GetPartSize(), t.GetSegmentID(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewCopyPartialStreamTask will create a CopyPartialStreamTask which meets navvy.Task.
func NewCopyPartialStreamTask(task navvy.Task) navvy.Task {
	return NewCopyPartialStream(task)
}

// CopySingleFileTask will execute a file copy operation between towo storager.
type CopySingleFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.MD5Sum
	types.Size
	types.SourcePath
	types.SourceStorage

	// Output value
}

// NewCopySingleFile will create a CopySingleFileTask struct and fetch inherited data from parent task.
func NewCopySingleFile(task navvy.Task) *CopySingleFileTask {
	t := &CopySingleFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopySingleFileTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopySingleFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopySingleFile value DestinationStorage is invalid"))
	}
	if !t.ValidateMD5Sum() {
		panic(fmt.Errorf("Task CopySingleFile value MD5Sum is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task CopySingleFile value Size is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopySingleFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopySingleFile value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopySingleFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadMD5Sum(task, t)
	types.LoadSize(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopySingleFileTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopySingleFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopySingleFileTask) String() string {
	return fmt.Sprintf("CopySingleFileTask {DestinationPath: %v, DestinationStorage: %v, MD5Sum: %v, Size: %v, SourcePath: %v, SourceStorage: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetMD5Sum(), t.GetSize(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewCopySingleFileTask will create a CopySingleFileTask which meets navvy.Task.
func NewCopySingleFileTask(task navvy.Task) navvy.Task {
	return NewCopySingleFile(task)
}

// CopySmallFileTask will copy a small file between two storager.
type CopySmallFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.Size
	types.SourcePath
	types.SourceStorage

	// Output value
	types.MD5Sum
}

// NewCopySmallFile will create a CopySmallFileTask struct and fetch inherited data from parent task.
func NewCopySmallFile(task navvy.Task) *CopySmallFileTask {
	t := &CopySmallFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopySmallFileTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopySmallFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopySmallFile value DestinationStorage is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task CopySmallFile value Size is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopySmallFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopySmallFile value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopySmallFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSize(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopySmallFileTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopySmallFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopySmallFileTask) String() string {
	return fmt.Sprintf("CopySmallFileTask {DestinationPath: %v, DestinationStorage: %v, Size: %v, SourcePath: %v, SourceStorage: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSize(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewCopySmallFileTask will create a CopySmallFileTask which meets navvy.Task.
func NewCopySmallFileTask(task navvy.Task) navvy.Task {
	return NewCopySmallFile(task)
}

// CopyStreamTask will copy a stream between two storager.
type CopyStreamTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Output value
	types.BytesPool
	types.PartSize
	types.SegmentID
}

// NewCopyStream will create a CopyStreamTask struct and fetch inherited data from parent task.
func NewCopyStream(task navvy.Task) *CopyStreamTask {
	t := &CopyStreamTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CopyStreamTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task CopyStream value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task CopyStream value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task CopyStream value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task CopyStream value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CopyStreamTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *CopyStreamTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *CopyStreamTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CopyStreamTask) String() string {
	return fmt.Sprintf("CopyStreamTask {DestinationPath: %v, DestinationStorage: %v, SourcePath: %v, SourceStorage: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewCopyStreamTask will create a CopyStreamTask which meets navvy.Task.
func NewCopyStreamTask(task navvy.Task) navvy.Task {
	return NewCopyStream(task)
}

// CreateStorageTask will create a storage.
type CreateStorageTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Service

	// Output value
	types.StorageName
	types.Zone
}

// NewCreateStorage will create a CreateStorageTask struct and fetch inherited data from parent task.
func NewCreateStorage(task navvy.Task) *CreateStorageTask {
	t := &CreateStorageTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *CreateStorageTask) validateInput() {
	if !t.ValidateService() {
		panic(fmt.Errorf("Task CreateStorage value Service is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *CreateStorageTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadService(task, t)
}

// Run implement navvy.Task
func (t *CreateStorageTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *CreateStorageTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *CreateStorageTask) String() string {
	return fmt.Sprintf("CreateStorageTask {Service: %v}", t.GetService())
}

// NewCreateStorageTask will create a CreateStorageTask which meets navvy.Task.
func NewCreateStorageTask(task navvy.Task) navvy.Task {
	return NewCreateStorage(task)
}

// DeleteDirTask will will delete a dir recursively.
type DeleteDirTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Path
	types.Storage

	// Output value
}

// NewDeleteDir will create a DeleteDirTask struct and fetch inherited data from parent task.
func NewDeleteDir(task navvy.Task) *DeleteDirTask {
	t := &DeleteDirTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeleteDirTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task DeleteDir value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task DeleteDir value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeleteDirTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *DeleteDirTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeleteDirTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *DeleteDirTask) String() string {
	return fmt.Sprintf("DeleteDirTask {Path: %v, Storage: %v}", t.GetPath(), t.GetStorage())
}

// NewDeleteDirTask will create a DeleteDirTask which meets navvy.Task.
func NewDeleteDirTask(task navvy.Task) navvy.Task {
	return NewDeleteDir(task)
}

// DeleteFileTask will will delete a file from storage.
type DeleteFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Path
	types.Storage

	// Output value
}

// NewDeleteFile will create a DeleteFileTask struct and fetch inherited data from parent task.
func NewDeleteFile(task navvy.Task) *DeleteFileTask {
	t := &DeleteFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeleteFileTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task DeleteFile value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task DeleteFile value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeleteFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *DeleteFileTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeleteFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *DeleteFileTask) String() string {
	return fmt.Sprintf("DeleteFileTask {Path: %v, Storage: %v}", t.GetPath(), t.GetStorage())
}

// NewDeleteFileTask will create a DeleteFileTask which meets navvy.Task.
func NewDeleteFileTask(task navvy.Task) navvy.Task {
	return NewDeleteFile(task)
}

// DeleteSegmentTask will delete all segments with a given path.
type DeleteSegmentTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.SegmentID
	types.Segmenter

	// Output value
}

// NewDeleteSegment will create a DeleteSegmentTask struct and fetch inherited data from parent task.
func NewDeleteSegment(task navvy.Task) *DeleteSegmentTask {
	t := &DeleteSegmentTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeleteSegmentTask) validateInput() {
	if !t.ValidateSegmentID() {
		panic(fmt.Errorf("Task DeleteSegment value SegmentID is invalid"))
	}
	if !t.ValidateSegmenter() {
		panic(fmt.Errorf("Task DeleteSegment value Segmenter is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeleteSegmentTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadSegmentID(task, t)
	types.LoadSegmenter(task, t)
}

// Run implement navvy.Task
func (t *DeleteSegmentTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeleteSegmentTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *DeleteSegmentTask) String() string {
	return fmt.Sprintf("DeleteSegmentTask {SegmentID: %v, Segmenter: %v}", t.GetSegmentID(), t.GetSegmenter())
}

// NewDeleteSegmentTask will create a DeleteSegmentTask which meets navvy.Task.
func NewDeleteSegmentTask(task navvy.Task) navvy.Task {
	return NewDeleteSegment(task)
}

// DeleteStorageTask will delete a storage.
type DeleteStorageTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Force
	types.Service
	types.StorageName

	// Output value
}

// NewDeleteStorage will create a DeleteStorageTask struct and fetch inherited data from parent task.
func NewDeleteStorage(task navvy.Task) *DeleteStorageTask {
	t := &DeleteStorageTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *DeleteStorageTask) validateInput() {
	if !t.ValidateForce() {
		panic(fmt.Errorf("Task DeleteStorage value Force is invalid"))
	}
	if !t.ValidateService() {
		panic(fmt.Errorf("Task DeleteStorage value Service is invalid"))
	}
	if !t.ValidateStorageName() {
		panic(fmt.Errorf("Task DeleteStorage value StorageName is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *DeleteStorageTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadForce(task, t)
	types.LoadService(task, t)
	types.LoadStorageName(task, t)
}

// Run implement navvy.Task
func (t *DeleteStorageTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *DeleteStorageTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *DeleteStorageTask) String() string {
	return fmt.Sprintf("DeleteStorageTask {Force: %v, Service: %v, StorageName: %v}", t.GetForce(), t.GetService(), t.GetStorageName())
}

// NewDeleteStorageTask will create a DeleteStorageTask which meets navvy.Task.
func NewDeleteStorageTask(task navvy.Task) navvy.Task {
	return NewDeleteStorage(task)
}

// IsDestinationObjectExistTask will .
type IsDestinationObjectExistTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationStorage

	// Output value
	types.Result
}

// NewIsDestinationObjectExist will create a IsDestinationObjectExistTask struct and fetch inherited data from parent task.
func NewIsDestinationObjectExist(task navvy.Task) *IsDestinationObjectExistTask {
	t := &IsDestinationObjectExistTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *IsDestinationObjectExistTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task IsDestinationObjectExist value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task IsDestinationObjectExist value DestinationStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *IsDestinationObjectExistTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
}

// Run implement navvy.Task
func (t *IsDestinationObjectExistTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *IsDestinationObjectExistTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *IsDestinationObjectExistTask) String() string {
	return fmt.Sprintf("IsDestinationObjectExistTask {DestinationPath: %v, DestinationStorage: %v}", t.GetDestinationPath(), t.GetDestinationStorage())
}

// NewIsDestinationObjectExistTask will create a IsDestinationObjectExistTask which meets navvy.Task.
func NewIsDestinationObjectExistTask(task navvy.Task) navvy.Task {
	return NewIsDestinationObjectExist(task)
}

// IsSizeEqualTask will .
type IsSizeEqualTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Output value
	types.Result
}

// NewIsSizeEqual will create a IsSizeEqualTask struct and fetch inherited data from parent task.
func NewIsSizeEqual(task navvy.Task) *IsSizeEqualTask {
	t := &IsSizeEqualTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *IsSizeEqualTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task IsSizeEqual value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task IsSizeEqual value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task IsSizeEqual value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task IsSizeEqual value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *IsSizeEqualTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *IsSizeEqualTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *IsSizeEqualTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *IsSizeEqualTask) String() string {
	return fmt.Sprintf("IsSizeEqualTask {DestinationPath: %v, DestinationStorage: %v, SourcePath: %v, SourceStorage: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewIsSizeEqualTask will create a IsSizeEqualTask which meets navvy.Task.
func NewIsSizeEqualTask(task navvy.Task) navvy.Task {
	return NewIsSizeEqual(task)
}

// IsUpdateAtGreaterTask will .
type IsUpdateAtGreaterTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Output value
	types.Result
}

// NewIsUpdateAtGreater will create a IsUpdateAtGreaterTask struct and fetch inherited data from parent task.
func NewIsUpdateAtGreater(task navvy.Task) *IsUpdateAtGreaterTask {
	t := &IsUpdateAtGreaterTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *IsUpdateAtGreaterTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task IsUpdateAtGreater value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task IsUpdateAtGreater value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task IsUpdateAtGreater value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task IsUpdateAtGreater value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *IsUpdateAtGreaterTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *IsUpdateAtGreaterTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *IsUpdateAtGreaterTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *IsUpdateAtGreaterTask) String() string {
	return fmt.Sprintf("IsUpdateAtGreaterTask {DestinationPath: %v, DestinationStorage: %v, SourcePath: %v, SourceStorage: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewIsUpdateAtGreaterTask will create a IsUpdateAtGreaterTask which meets navvy.Task.
func NewIsUpdateAtGreaterTask(task navvy.Task) navvy.Task {
	return NewIsUpdateAtGreater(task)
}

// ListDirTask will list dirs.
type ListDirTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DirFunc
	types.FileFunc
	types.Path
	types.Storage

	// Output value
}

// NewListDir will create a ListDirTask struct and fetch inherited data from parent task.
func NewListDir(task navvy.Task) *ListDirTask {
	t := &ListDirTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ListDirTask) validateInput() {
	if !t.ValidateDirFunc() {
		panic(fmt.Errorf("Task ListDir value DirFunc is invalid"))
	}
	if !t.ValidateFileFunc() {
		panic(fmt.Errorf("Task ListDir value FileFunc is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task ListDir value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task ListDir value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ListDirTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDirFunc(task, t)
	types.LoadFileFunc(task, t)
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *ListDirTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *ListDirTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *ListDirTask) String() string {
	return fmt.Sprintf("ListDirTask {Path: %v, Storage: %v}", t.GetPath(), t.GetStorage())
}

// NewListDirTask will create a ListDirTask which meets navvy.Task.
func NewListDirTask(task navvy.Task) navvy.Task {
	return NewListDir(task)
}

// ListSegmentTask will list segments.
type ListSegmentTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Path
	types.SegmentFunc
	types.Segmenter

	// Output value
}

// NewListSegment will create a ListSegmentTask struct and fetch inherited data from parent task.
func NewListSegment(task navvy.Task) *ListSegmentTask {
	t := &ListSegmentTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ListSegmentTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task ListSegment value Path is invalid"))
	}
	if !t.ValidateSegmentFunc() {
		panic(fmt.Errorf("Task ListSegment value SegmentFunc is invalid"))
	}
	if !t.ValidateSegmenter() {
		panic(fmt.Errorf("Task ListSegment value Segmenter is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ListSegmentTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadSegmentFunc(task, t)
	types.LoadSegmenter(task, t)
}

// Run implement navvy.Task
func (t *ListSegmentTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *ListSegmentTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *ListSegmentTask) String() string {
	return fmt.Sprintf("ListSegmentTask {Path: %v, Segmenter: %v}", t.GetPath(), t.GetSegmenter())
}

// NewListSegmentTask will create a ListSegmentTask which meets navvy.Task.
func NewListSegmentTask(task navvy.Task) navvy.Task {
	return NewListSegment(task)
}

// ListStorageTask will send get request to get bucket list.
type ListStorageTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Service
	types.StoragerFunc
	types.Zone

	// Output value
}

// NewListStorage will create a ListStorageTask struct and fetch inherited data from parent task.
func NewListStorage(task navvy.Task) *ListStorageTask {
	t := &ListStorageTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ListStorageTask) validateInput() {
	if !t.ValidateService() {
		panic(fmt.Errorf("Task ListStorage value Service is invalid"))
	}
	if !t.ValidateStoragerFunc() {
		panic(fmt.Errorf("Task ListStorage value StoragerFunc is invalid"))
	}
	if !t.ValidateZone() {
		panic(fmt.Errorf("Task ListStorage value Zone is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ListStorageTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadService(task, t)
	types.LoadStoragerFunc(task, t)
	types.LoadZone(task, t)
}

// Run implement navvy.Task
func (t *ListStorageTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *ListStorageTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *ListStorageTask) String() string {
	return fmt.Sprintf("ListStorageTask {Service: %v, Zone: %v}", t.GetService(), t.GetZone())
}

// NewListStorageTask will create a ListStorageTask which meets navvy.Task.
func NewListStorageTask(task navvy.Task) navvy.Task {
	return NewListStorage(task)
}

// MD5SumFileTask will get file's md5 sum.
type MD5SumFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Offset
	types.Path
	types.Size
	types.Storage

	// Output value
	types.MD5Sum
}

// NewMD5SumFile will create a MD5SumFileTask struct and fetch inherited data from parent task.
func NewMD5SumFile(task navvy.Task) *MD5SumFileTask {
	t := &MD5SumFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *MD5SumFileTask) validateInput() {
	if !t.ValidateOffset() {
		panic(fmt.Errorf("Task MD5SumFile value Offset is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task MD5SumFile value Path is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task MD5SumFile value Size is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task MD5SumFile value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *MD5SumFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadOffset(task, t)
	types.LoadPath(task, t)
	types.LoadSize(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *MD5SumFileTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *MD5SumFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *MD5SumFileTask) String() string {
	return fmt.Sprintf("MD5SumFileTask {Offset: %v, Path: %v, Size: %v, Storage: %v}", t.GetOffset(), t.GetPath(), t.GetSize(), t.GetStorage())
}

// NewMD5SumFileTask will create a MD5SumFileTask which meets navvy.Task.
func NewMD5SumFileTask(task navvy.Task) navvy.Task {
	return NewMD5SumFile(task)
}

// MD5SumStreamTask will get stream's md5 sum.
type MD5SumStreamTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Content

	// Output value
	types.MD5Sum
}

// NewMD5SumStream will create a MD5SumStreamTask struct and fetch inherited data from parent task.
func NewMD5SumStream(task navvy.Task) *MD5SumStreamTask {
	t := &MD5SumStreamTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *MD5SumStreamTask) validateInput() {
	if !t.ValidateContent() {
		panic(fmt.Errorf("Task MD5SumStream value Content is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *MD5SumStreamTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadContent(task, t)
}

// Run implement navvy.Task
func (t *MD5SumStreamTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *MD5SumStreamTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *MD5SumStreamTask) String() string {
	return fmt.Sprintf("MD5SumStreamTask {Content: %v}", t.GetContent())
}

// NewMD5SumStreamTask will create a MD5SumStreamTask which meets navvy.Task.
func NewMD5SumStreamTask(task navvy.Task) navvy.Task {
	return NewMD5SumStream(task)
}

// MoveDirTask will move a directory recursively between two storager.
type MoveDirTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Output value
}

// NewMoveDir will create a MoveDirTask struct and fetch inherited data from parent task.
func NewMoveDir(task navvy.Task) *MoveDirTask {
	t := &MoveDirTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *MoveDirTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task MoveDir value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task MoveDir value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task MoveDir value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task MoveDir value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *MoveDirTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *MoveDirTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *MoveDirTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *MoveDirTask) String() string {
	return fmt.Sprintf("MoveDirTask {DestinationPath: %v, DestinationStorage: %v, SourcePath: %v, SourceStorage: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewMoveDirTask will create a MoveDirTask which meets navvy.Task.
func NewMoveDirTask(task navvy.Task) navvy.Task {
	return NewMoveDir(task)
}

// MoveFileTask will move a file between two storager.
type MoveFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.SourcePath
	types.SourceStorage

	// Output value
}

// NewMoveFile will create a MoveFileTask struct and fetch inherited data from parent task.
func NewMoveFile(task navvy.Task) *MoveFileTask {
	t := &MoveFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *MoveFileTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task MoveFile value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task MoveFile value DestinationStorage is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task MoveFile value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task MoveFile value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *MoveFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *MoveFileTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *MoveFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *MoveFileTask) String() string {
	return fmt.Sprintf("MoveFileTask {DestinationPath: %v, DestinationStorage: %v, SourcePath: %v, SourceStorage: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewMoveFileTask will create a MoveFileTask which meets navvy.Task.
func NewMoveFileTask(task navvy.Task) navvy.Task {
	return NewMoveFile(task)
}

// ReachFileTask will will reach a remote object and return the signed url.
type ReachFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Expire
	types.Path
	types.Reacher

	// Output value
	types.URL
}

// NewReachFile will create a ReachFileTask struct and fetch inherited data from parent task.
func NewReachFile(task navvy.Task) *ReachFileTask {
	t := &ReachFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *ReachFileTask) validateInput() {
	if !t.ValidateExpire() {
		panic(fmt.Errorf("Task ReachFile value Expire is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task ReachFile value Path is invalid"))
	}
	if !t.ValidateReacher() {
		panic(fmt.Errorf("Task ReachFile value Reacher is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *ReachFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadExpire(task, t)
	types.LoadPath(task, t)
	types.LoadReacher(task, t)
}

// Run implement navvy.Task
func (t *ReachFileTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *ReachFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *ReachFileTask) String() string {
	return fmt.Sprintf("ReachFileTask {Expire: %v, Path: %v, Reacher: %v}", t.GetExpire(), t.GetPath(), t.GetReacher())
}

// NewReachFileTask will create a ReachFileTask which meets navvy.Task.
func NewReachFileTask(task navvy.Task) navvy.Task {
	return NewReachFile(task)
}

// SegmentCompleteTask will complete a segment.
type SegmentCompleteTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Path
	types.SegmentID
	types.Segmenter

	// Output value
}

// NewSegmentComplete will create a SegmentCompleteTask struct and fetch inherited data from parent task.
func NewSegmentComplete(task navvy.Task) *SegmentCompleteTask {
	t := &SegmentCompleteTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SegmentCompleteTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task SegmentComplete value Path is invalid"))
	}
	if !t.ValidateSegmentID() {
		panic(fmt.Errorf("Task SegmentComplete value SegmentID is invalid"))
	}
	if !t.ValidateSegmenter() {
		panic(fmt.Errorf("Task SegmentComplete value Segmenter is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SegmentCompleteTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadSegmentID(task, t)
	types.LoadSegmenter(task, t)
}

// Run implement navvy.Task
func (t *SegmentCompleteTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *SegmentCompleteTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *SegmentCompleteTask) String() string {
	return fmt.Sprintf("SegmentCompleteTask {Path: %v, SegmentID: %v, Segmenter: %v}", t.GetPath(), t.GetSegmentID(), t.GetSegmenter())
}

// NewSegmentCompleteTask will create a SegmentCompleteTask which meets navvy.Task.
func NewSegmentCompleteTask(task navvy.Task) navvy.Task {
	return NewSegmentComplete(task)
}

// SegmentFileCopyTask will copy a segment file.
type SegmentFileCopyTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationSegmenter
	types.MD5Sum
	types.Offset
	types.SegmentID
	types.Size
	types.SourcePath
	types.SourceStorage

	// Output value
}

// NewSegmentFileCopy will create a SegmentFileCopyTask struct and fetch inherited data from parent task.
func NewSegmentFileCopy(task navvy.Task) *SegmentFileCopyTask {
	t := &SegmentFileCopyTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SegmentFileCopyTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task SegmentFileCopy value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationSegmenter() {
		panic(fmt.Errorf("Task SegmentFileCopy value DestinationSegmenter is invalid"))
	}
	if !t.ValidateMD5Sum() {
		panic(fmt.Errorf("Task SegmentFileCopy value MD5Sum is invalid"))
	}
	if !t.ValidateOffset() {
		panic(fmt.Errorf("Task SegmentFileCopy value Offset is invalid"))
	}
	if !t.ValidateSegmentID() {
		panic(fmt.Errorf("Task SegmentFileCopy value SegmentID is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task SegmentFileCopy value Size is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task SegmentFileCopy value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task SegmentFileCopy value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SegmentFileCopyTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationSegmenter(task, t)
	types.LoadMD5Sum(task, t)
	types.LoadOffset(task, t)
	types.LoadSegmentID(task, t)
	types.LoadSize(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *SegmentFileCopyTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *SegmentFileCopyTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *SegmentFileCopyTask) String() string {
	return fmt.Sprintf("SegmentFileCopyTask {DestinationPath: %v, DestinationSegmenter: %v, MD5Sum: %v, Offset: %v, SegmentID: %v, Size: %v, SourcePath: %v, SourceStorage: %v}", t.GetDestinationPath(), t.GetDestinationSegmenter(), t.GetMD5Sum(), t.GetOffset(), t.GetSegmentID(), t.GetSize(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewSegmentFileCopyTask will create a SegmentFileCopyTask which meets navvy.Task.
func NewSegmentFileCopyTask(task navvy.Task) navvy.Task {
	return NewSegmentFileCopy(task)
}

// SegmentInitTask will init a segment upload.
type SegmentInitTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.PartSize
	types.Path
	types.Segmenter

	// Output value
	types.SegmentID
}

// NewSegmentInit will create a SegmentInitTask struct and fetch inherited data from parent task.
func NewSegmentInit(task navvy.Task) *SegmentInitTask {
	t := &SegmentInitTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SegmentInitTask) validateInput() {
	if !t.ValidatePartSize() {
		panic(fmt.Errorf("Task SegmentInit value PartSize is invalid"))
	}
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task SegmentInit value Path is invalid"))
	}
	if !t.ValidateSegmenter() {
		panic(fmt.Errorf("Task SegmentInit value Segmenter is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SegmentInitTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPartSize(task, t)
	types.LoadPath(task, t)
	types.LoadSegmenter(task, t)
}

// Run implement navvy.Task
func (t *SegmentInitTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *SegmentInitTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *SegmentInitTask) String() string {
	return fmt.Sprintf("SegmentInitTask {PartSize: %v, Path: %v, Segmenter: %v}", t.GetPartSize(), t.GetPath(), t.GetSegmenter())
}

// NewSegmentInitTask will create a SegmentInitTask which meets navvy.Task.
func NewSegmentInitTask(task navvy.Task) navvy.Task {
	return NewSegmentInit(task)
}

// SegmentStreamCopyTask will copy a segment stream.
type SegmentStreamCopyTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Content
	types.DestinationPath
	types.MD5Sum
	types.Offset
	types.SegmentID
	types.Segmenter
	types.Size

	// Output value
}

// NewSegmentStreamCopy will create a SegmentStreamCopyTask struct and fetch inherited data from parent task.
func NewSegmentStreamCopy(task navvy.Task) *SegmentStreamCopyTask {
	t := &SegmentStreamCopyTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SegmentStreamCopyTask) validateInput() {
	if !t.ValidateContent() {
		panic(fmt.Errorf("Task SegmentStreamCopy value Content is invalid"))
	}
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task SegmentStreamCopy value DestinationPath is invalid"))
	}
	if !t.ValidateMD5Sum() {
		panic(fmt.Errorf("Task SegmentStreamCopy value MD5Sum is invalid"))
	}
	if !t.ValidateOffset() {
		panic(fmt.Errorf("Task SegmentStreamCopy value Offset is invalid"))
	}
	if !t.ValidateSegmentID() {
		panic(fmt.Errorf("Task SegmentStreamCopy value SegmentID is invalid"))
	}
	if !t.ValidateSegmenter() {
		panic(fmt.Errorf("Task SegmentStreamCopy value Segmenter is invalid"))
	}
	if !t.ValidateSize() {
		panic(fmt.Errorf("Task SegmentStreamCopy value Size is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SegmentStreamCopyTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadContent(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadMD5Sum(task, t)
	types.LoadOffset(task, t)
	types.LoadSegmentID(task, t)
	types.LoadSegmenter(task, t)
	types.LoadSize(task, t)
}

// Run implement navvy.Task
func (t *SegmentStreamCopyTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *SegmentStreamCopyTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *SegmentStreamCopyTask) String() string {
	return fmt.Sprintf("SegmentStreamCopyTask {Content: %v, DestinationPath: %v, MD5Sum: %v, Offset: %v, SegmentID: %v, Segmenter: %v, Size: %v}", t.GetContent(), t.GetDestinationPath(), t.GetMD5Sum(), t.GetOffset(), t.GetSegmentID(), t.GetSegmenter(), t.GetSize())
}

// NewSegmentStreamCopyTask will create a SegmentStreamCopyTask which meets navvy.Task.
func NewSegmentStreamCopyTask(task navvy.Task) navvy.Task {
	return NewSegmentStreamCopy(task)
}

// StatFileTask will stat a remote object by request headObject.
type StatFileTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.Path
	types.Storage

	// Output value
	types.Object
}

// NewStatFile will create a StatFileTask struct and fetch inherited data from parent task.
func NewStatFile(task navvy.Task) *StatFileTask {
	t := &StatFileTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *StatFileTask) validateInput() {
	if !t.ValidatePath() {
		panic(fmt.Errorf("Task StatFile value Path is invalid"))
	}
	if !t.ValidateStorage() {
		panic(fmt.Errorf("Task StatFile value Storage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *StatFileTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadPath(task, t)
	types.LoadStorage(task, t)
}

// Run implement navvy.Task
func (t *StatFileTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *StatFileTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *StatFileTask) String() string {
	return fmt.Sprintf("StatFileTask {Path: %v, Storage: %v}", t.GetPath(), t.GetStorage())
}

// NewStatFileTask will create a StatFileTask which meets navvy.Task.
func NewStatFileTask(task navvy.Task) navvy.Task {
	return NewStatFile(task)
}

// SyncTask will sync directory between two storage.
type SyncTask struct {
	// Predefined value
	types.Fault
	types.ID
	types.Pool
	types.Scheduler

	// Input value
	types.DestinationPath
	types.DestinationStorage
	types.IgnoreExisting
	types.SourcePath
	types.SourceStorage

	// Output value
}

// NewSync will create a SyncTask struct and fetch inherited data from parent task.
func NewSync(task navvy.Task) *SyncTask {
	t := &SyncTask{}
	t.SetID(uuid.New().String())

	t.loadInput(task)
	t.SetScheduler(schedule.NewScheduler(t.GetPool()))

	t.new()
	return t
}

// validateInput will validate all input before run task.
func (t *SyncTask) validateInput() {
	if !t.ValidateDestinationPath() {
		panic(fmt.Errorf("Task Sync value DestinationPath is invalid"))
	}
	if !t.ValidateDestinationStorage() {
		panic(fmt.Errorf("Task Sync value DestinationStorage is invalid"))
	}
	if !t.ValidateIgnoreExisting() {
		panic(fmt.Errorf("Task Sync value IgnoreExisting is invalid"))
	}
	if !t.ValidateSourcePath() {
		panic(fmt.Errorf("Task Sync value SourcePath is invalid"))
	}
	if !t.ValidateSourceStorage() {
		panic(fmt.Errorf("Task Sync value SourceStorage is invalid"))
	}
}

// loadInput will check and load all input before new task.
func (t *SyncTask) loadInput(task navvy.Task) {
	types.LoadFault(task, t)
	types.LoadPool(task, t)
	types.LoadDestinationPath(task, t)
	types.LoadDestinationStorage(task, t)
	types.LoadIgnoreExisting(task, t)
	types.LoadSourcePath(task, t)
	types.LoadSourceStorage(task, t)
}

// Run implement navvy.Task
func (t *SyncTask) Run() {
	t.validateInput()

	log.Debugf("Started %s", t)
	t.run()
	t.GetScheduler().Wait()
	log.Debugf("Finished %s", t)
}

// TriggerFault will be used to trigger a task related fault.
func (t *SyncTask) TriggerFault(err error) {
	t.GetFault().Append(fmt.Errorf("Failed %s: {%w}", t, err))
}

// String will implement Stringer interface.
func (t *SyncTask) String() string {
	return fmt.Sprintf("SyncTask {DestinationPath: %v, DestinationStorage: %v, IgnoreExisting: %v, SourcePath: %v, SourceStorage: %v}", t.GetDestinationPath(), t.GetDestinationStorage(), t.GetIgnoreExisting(), t.GetSourcePath(), t.GetSourceStorage())
}

// NewSyncTask will create a SyncTask which meets navvy.Task.
func NewSyncTask(task navvy.Task) navvy.Task {
	return NewSync(task)
}
