// Code generated by go generate; DO NOT EDIT.
package task

import (
	"errors"
	"testing"

	"github.com/Xuanwo/navvy"
	"github.com/stretchr/testify/assert"

	"github.com/yunify/qsctl/v2/pkg/types"
)

var _ navvy.Pool
var _ types.Pool

func TestNewCopyTask(t *testing.T) {
	m := &mockCopyTask{}
	task := NewCopyTask(m)
	assert.NotNil(t, task)
}

func TestCopyTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockCopyTask{}
			m.SetPool(pool)
			task := &CopyTask{copyTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestCopyTask_TriggerFault(t *testing.T) {
	m := &mockCopyTask{}
	task := &CopyTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.copyTaskRequirement.ValidateFault())
}

func TestMockCopyTask_Run(t *testing.T) {
	task := &mockCopyTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewCopyFileTask(t *testing.T) {
	m := &mockCopyFileTask{}
	task := NewCopyFileTask(m)
	assert.NotNil(t, task)
}

func TestCopyFileTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockCopyFileTask{}
			m.SetPool(pool)
			task := &CopyFileTask{copyFileTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestCopyFileTask_TriggerFault(t *testing.T) {
	m := &mockCopyFileTask{}
	task := &CopyFileTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.copyFileTaskRequirement.ValidateFault())
}

func TestMockCopyFileTask_Run(t *testing.T) {
	task := &mockCopyFileTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewCopyLargeFileTask(t *testing.T) {
	m := &mockCopyLargeFileTask{}
	task := NewCopyLargeFileTask(m)
	assert.NotNil(t, task)
}

func TestCopyLargeFileTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockCopyLargeFileTask{}
			m.SetPool(pool)
			task := &CopyLargeFileTask{copyLargeFileTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestCopyLargeFileTask_TriggerFault(t *testing.T) {
	m := &mockCopyLargeFileTask{}
	task := &CopyLargeFileTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.copyLargeFileTaskRequirement.ValidateFault())
}

func TestMockCopyLargeFileTask_Run(t *testing.T) {
	task := &mockCopyLargeFileTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewCopyPartialFileTask(t *testing.T) {
	m := &mockCopyPartialFileTask{}
	task := NewCopyPartialFileTask(m)
	assert.NotNil(t, task)
}

func TestCopyPartialFileTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockCopyPartialFileTask{}
			m.SetPool(pool)
			task := &CopyPartialFileTask{copyPartialFileTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestCopyPartialFileTask_TriggerFault(t *testing.T) {
	m := &mockCopyPartialFileTask{}
	task := &CopyPartialFileTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.copyPartialFileTaskRequirement.ValidateFault())
}

func TestMockCopyPartialFileTask_Run(t *testing.T) {
	task := &mockCopyPartialFileTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewCopyPartialStreamTask(t *testing.T) {
	m := &mockCopyPartialStreamTask{}
	task := NewCopyPartialStreamTask(m)
	assert.NotNil(t, task)
}

func TestCopyPartialStreamTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockCopyPartialStreamTask{}
			m.SetPool(pool)
			task := &CopyPartialStreamTask{copyPartialStreamTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestCopyPartialStreamTask_TriggerFault(t *testing.T) {
	m := &mockCopyPartialStreamTask{}
	task := &CopyPartialStreamTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.copyPartialStreamTaskRequirement.ValidateFault())
}

func TestMockCopyPartialStreamTask_Run(t *testing.T) {
	task := &mockCopyPartialStreamTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewCopySmallFileTask(t *testing.T) {
	m := &mockCopySmallFileTask{}
	task := NewCopySmallFileTask(m)
	assert.NotNil(t, task)
}

func TestCopySmallFileTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockCopySmallFileTask{}
			m.SetPool(pool)
			task := &CopySmallFileTask{copySmallFileTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestCopySmallFileTask_TriggerFault(t *testing.T) {
	m := &mockCopySmallFileTask{}
	task := &CopySmallFileTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.copySmallFileTaskRequirement.ValidateFault())
}

func TestMockCopySmallFileTask_Run(t *testing.T) {
	task := &mockCopySmallFileTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewCopyStreamTask(t *testing.T) {
	m := &mockCopyStreamTask{}
	task := NewCopyStreamTask(m)
	assert.NotNil(t, task)
}

func TestCopyStreamTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockCopyStreamTask{}
			m.SetPool(pool)
			task := &CopyStreamTask{copyStreamTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestCopyStreamTask_TriggerFault(t *testing.T) {
	m := &mockCopyStreamTask{}
	task := &CopyStreamTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.copyStreamTaskRequirement.ValidateFault())
}

func TestMockCopyStreamTask_Run(t *testing.T) {
	task := &mockCopyStreamTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewCreateStorageTask(t *testing.T) {
	m := &mockCreateStorageTask{}
	task := NewCreateStorageTask(m)
	assert.NotNil(t, task)
}

func TestCreateStorageTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockCreateStorageTask{}
			m.SetPool(pool)
			task := &CreateStorageTask{createStorageTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestCreateStorageTask_TriggerFault(t *testing.T) {
	m := &mockCreateStorageTask{}
	task := &CreateStorageTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.createStorageTaskRequirement.ValidateFault())
}

func TestMockCreateStorageTask_Run(t *testing.T) {
	task := &mockCreateStorageTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewDeleteDirTask(t *testing.T) {
	m := &mockDeleteDirTask{}
	task := NewDeleteDirTask(m)
	assert.NotNil(t, task)
}

func TestDeleteDirTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockDeleteDirTask{}
			m.SetPool(pool)
			task := &DeleteDirTask{deleteDirTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestDeleteDirTask_TriggerFault(t *testing.T) {
	m := &mockDeleteDirTask{}
	task := &DeleteDirTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.deleteDirTaskRequirement.ValidateFault())
}

func TestMockDeleteDirTask_Run(t *testing.T) {
	task := &mockDeleteDirTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewDeleteFileTask(t *testing.T) {
	m := &mockDeleteFileTask{}
	task := NewDeleteFileTask(m)
	assert.NotNil(t, task)
}

func TestDeleteFileTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockDeleteFileTask{}
			m.SetPool(pool)
			task := &DeleteFileTask{deleteFileTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestDeleteFileTask_TriggerFault(t *testing.T) {
	m := &mockDeleteFileTask{}
	task := &DeleteFileTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.deleteFileTaskRequirement.ValidateFault())
}

func TestMockDeleteFileTask_Run(t *testing.T) {
	task := &mockDeleteFileTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewDeleteStorageTask(t *testing.T) {
	m := &mockDeleteStorageTask{}
	task := NewDeleteStorageTask(m)
	assert.NotNil(t, task)
}

func TestDeleteStorageTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockDeleteStorageTask{}
			m.SetPool(pool)
			task := &DeleteStorageTask{deleteStorageTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestDeleteStorageTask_TriggerFault(t *testing.T) {
	m := &mockDeleteStorageTask{}
	task := &DeleteStorageTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.deleteStorageTaskRequirement.ValidateFault())
}

func TestMockDeleteStorageTask_Run(t *testing.T) {
	task := &mockDeleteStorageTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewDeleteStorageForceTask(t *testing.T) {
	m := &mockDeleteStorageForceTask{}
	task := NewDeleteStorageForceTask(m)
	assert.NotNil(t, task)
}

func TestDeleteStorageForceTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockDeleteStorageForceTask{}
			m.SetPool(pool)
			task := &DeleteStorageForceTask{deleteStorageForceTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestDeleteStorageForceTask_TriggerFault(t *testing.T) {
	m := &mockDeleteStorageForceTask{}
	task := &DeleteStorageForceTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.deleteStorageForceTaskRequirement.ValidateFault())
}

func TestMockDeleteStorageForceTask_Run(t *testing.T) {
	task := &mockDeleteStorageForceTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewFileCopyTask(t *testing.T) {
	m := &mockFileCopyTask{}
	task := NewFileCopyTask(m)
	assert.NotNil(t, task)
}

func TestFileCopyTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockFileCopyTask{}
			m.SetPool(pool)
			task := &FileCopyTask{fileCopyTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestFileCopyTask_TriggerFault(t *testing.T) {
	m := &mockFileCopyTask{}
	task := &FileCopyTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.fileCopyTaskRequirement.ValidateFault())
}

func TestMockFileCopyTask_Run(t *testing.T) {
	task := &mockFileCopyTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewFileMD5SumTask(t *testing.T) {
	m := &mockFileMD5SumTask{}
	task := NewFileMD5SumTask(m)
	assert.NotNil(t, task)
}

func TestFileMD5SumTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockFileMD5SumTask{}
			m.SetPool(pool)
			task := &FileMD5SumTask{fileMD5SumTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestFileMD5SumTask_TriggerFault(t *testing.T) {
	m := &mockFileMD5SumTask{}
	task := &FileMD5SumTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.fileMD5SumTaskRequirement.ValidateFault())
}

func TestMockFileMD5SumTask_Run(t *testing.T) {
	task := &mockFileMD5SumTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewIterateFileTask(t *testing.T) {
	m := &mockIterateFileTask{}
	task := NewIterateFileTask(m)
	assert.NotNil(t, task)
}

func TestIterateFileTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockIterateFileTask{}
			m.SetPool(pool)
			task := &IterateFileTask{iterateFileTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestIterateFileTask_TriggerFault(t *testing.T) {
	m := &mockIterateFileTask{}
	task := &IterateFileTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.iterateFileTaskRequirement.ValidateFault())
}

func TestMockIterateFileTask_Run(t *testing.T) {
	task := &mockIterateFileTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewListFileTask(t *testing.T) {
	m := &mockListFileTask{}
	task := NewListFileTask(m)
	assert.NotNil(t, task)
}

func TestListFileTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockListFileTask{}
			m.SetPool(pool)
			task := &ListFileTask{listFileTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestListFileTask_TriggerFault(t *testing.T) {
	m := &mockListFileTask{}
	task := &ListFileTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.listFileTaskRequirement.ValidateFault())
}

func TestMockListFileTask_Run(t *testing.T) {
	task := &mockListFileTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewListStorageTask(t *testing.T) {
	m := &mockListStorageTask{}
	task := NewListStorageTask(m)
	assert.NotNil(t, task)
}

func TestListStorageTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockListStorageTask{}
			m.SetPool(pool)
			task := &ListStorageTask{listStorageTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestListStorageTask_TriggerFault(t *testing.T) {
	m := &mockListStorageTask{}
	task := &ListStorageTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.listStorageTaskRequirement.ValidateFault())
}

func TestMockListStorageTask_Run(t *testing.T) {
	task := &mockListStorageTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewReachTask(t *testing.T) {
	m := &mockReachTask{}
	task := NewReachTask(m)
	assert.NotNil(t, task)
}

func TestReachTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockReachTask{}
			m.SetPool(pool)
			task := &ReachTask{reachTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestReachTask_TriggerFault(t *testing.T) {
	m := &mockReachTask{}
	task := &ReachTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.reachTaskRequirement.ValidateFault())
}

func TestMockReachTask_Run(t *testing.T) {
	task := &mockReachTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewSegmentAbortAllTask(t *testing.T) {
	m := &mockSegmentAbortAllTask{}
	task := NewSegmentAbortAllTask(m)
	assert.NotNil(t, task)
}

func TestSegmentAbortAllTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockSegmentAbortAllTask{}
			m.SetPool(pool)
			task := &SegmentAbortAllTask{segmentAbortAllTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestSegmentAbortAllTask_TriggerFault(t *testing.T) {
	m := &mockSegmentAbortAllTask{}
	task := &SegmentAbortAllTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.segmentAbortAllTaskRequirement.ValidateFault())
}

func TestMockSegmentAbortAllTask_Run(t *testing.T) {
	task := &mockSegmentAbortAllTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewSegmentCompleteTask(t *testing.T) {
	m := &mockSegmentCompleteTask{}
	task := NewSegmentCompleteTask(m)
	assert.NotNil(t, task)
}

func TestSegmentCompleteTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockSegmentCompleteTask{}
			m.SetPool(pool)
			task := &SegmentCompleteTask{segmentCompleteTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestSegmentCompleteTask_TriggerFault(t *testing.T) {
	m := &mockSegmentCompleteTask{}
	task := &SegmentCompleteTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.segmentCompleteTaskRequirement.ValidateFault())
}

func TestMockSegmentCompleteTask_Run(t *testing.T) {
	task := &mockSegmentCompleteTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewSegmentFileCopyTask(t *testing.T) {
	m := &mockSegmentFileCopyTask{}
	task := NewSegmentFileCopyTask(m)
	assert.NotNil(t, task)
}

func TestSegmentFileCopyTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockSegmentFileCopyTask{}
			m.SetPool(pool)
			task := &SegmentFileCopyTask{segmentFileCopyTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestSegmentFileCopyTask_TriggerFault(t *testing.T) {
	m := &mockSegmentFileCopyTask{}
	task := &SegmentFileCopyTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.segmentFileCopyTaskRequirement.ValidateFault())
}

func TestMockSegmentFileCopyTask_Run(t *testing.T) {
	task := &mockSegmentFileCopyTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewSegmentInitTask(t *testing.T) {
	m := &mockSegmentInitTask{}
	task := NewSegmentInitTask(m)
	assert.NotNil(t, task)
}

func TestSegmentInitTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockSegmentInitTask{}
			m.SetPool(pool)
			task := &SegmentInitTask{segmentInitTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestSegmentInitTask_TriggerFault(t *testing.T) {
	m := &mockSegmentInitTask{}
	task := &SegmentInitTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.segmentInitTaskRequirement.ValidateFault())
}

func TestMockSegmentInitTask_Run(t *testing.T) {
	task := &mockSegmentInitTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewSegmentStreamCopyTask(t *testing.T) {
	m := &mockSegmentStreamCopyTask{}
	task := NewSegmentStreamCopyTask(m)
	assert.NotNil(t, task)
}

func TestSegmentStreamCopyTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockSegmentStreamCopyTask{}
			m.SetPool(pool)
			task := &SegmentStreamCopyTask{segmentStreamCopyTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestSegmentStreamCopyTask_TriggerFault(t *testing.T) {
	m := &mockSegmentStreamCopyTask{}
	task := &SegmentStreamCopyTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.segmentStreamCopyTaskRequirement.ValidateFault())
}

func TestMockSegmentStreamCopyTask_Run(t *testing.T) {
	task := &mockSegmentStreamCopyTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewStatTask(t *testing.T) {
	m := &mockStatTask{}
	task := NewStatTask(m)
	assert.NotNil(t, task)
}

func TestStatTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockStatTask{}
			m.SetPool(pool)
			task := &StatTask{statTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestStatTask_TriggerFault(t *testing.T) {
	m := &mockStatTask{}
	task := &StatTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.statTaskRequirement.ValidateFault())
}

func TestMockStatTask_Run(t *testing.T) {
	task := &mockStatTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewStreamMD5SumTask(t *testing.T) {
	m := &mockStreamMD5SumTask{}
	task := NewStreamMD5SumTask(m)
	assert.NotNil(t, task)
}

func TestStreamMD5SumTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockStreamMD5SumTask{}
			m.SetPool(pool)
			task := &StreamMD5SumTask{streamMD5SumTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestStreamMD5SumTask_TriggerFault(t *testing.T) {
	m := &mockStreamMD5SumTask{}
	task := &StreamMD5SumTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.streamMD5SumTaskRequirement.ValidateFault())
}

func TestMockStreamMD5SumTask_Run(t *testing.T) {
	task := &mockStreamMD5SumTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}
