// Code generated by go generate; DO NOT EDIT.
package task

import (
	"errors"
	"testing"

	"github.com/Xuanwo/navvy"
	"github.com/stretchr/testify/assert"

	"github.com/yunify/qsctl/v2/pkg/types"
)

var _ navvy.Pool
var _ types.Pool

func TestNewAbortMultipartTask(t *testing.T) {
	m := &mockAbortMultipartTask{}
	task := NewAbortMultipartTask(m)
	assert.NotNil(t, task)
}

func TestAbortMultipartTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockAbortMultipartTask{}
			m.SetPool(pool)
			task := &AbortMultipartTask{abortMultipartTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestAbortMultipartTask_TriggerFault(t *testing.T) {
	m := &mockAbortMultipartTask{}
	task := &AbortMultipartTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.abortMultipartTaskRequirement.ValidateFault())
}

func TestMockAbortMultipartTask_Run(t *testing.T) {
	task := &mockAbortMultipartTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewBucketCreateTask(t *testing.T) {
	m := &mockBucketCreateTask{}
	task := NewBucketCreateTask(m)
	assert.NotNil(t, task)
}

func TestBucketCreateTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockBucketCreateTask{}
			m.SetPool(pool)
			task := &BucketCreateTask{bucketCreateTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestBucketCreateTask_TriggerFault(t *testing.T) {
	m := &mockBucketCreateTask{}
	task := &BucketCreateTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.bucketCreateTaskRequirement.ValidateFault())
}

func TestMockBucketCreateTask_Run(t *testing.T) {
	task := &mockBucketCreateTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewBucketListTask(t *testing.T) {
	m := &mockBucketListTask{}
	task := NewBucketListTask(m)
	assert.NotNil(t, task)
}

func TestBucketListTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockBucketListTask{}
			m.SetPool(pool)
			task := &BucketListTask{bucketListTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestBucketListTask_TriggerFault(t *testing.T) {
	m := &mockBucketListTask{}
	task := &BucketListTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.bucketListTaskRequirement.ValidateFault())
}

func TestMockBucketListTask_Run(t *testing.T) {
	task := &mockBucketListTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewCopyTask(t *testing.T) {
	m := &mockCopyTask{}
	task := NewCopyTask(m)
	assert.NotNil(t, task)
}

func TestCopyTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockCopyTask{}
			m.SetPool(pool)
			task := &CopyTask{copyTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestCopyTask_TriggerFault(t *testing.T) {
	m := &mockCopyTask{}
	task := &CopyTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.copyTaskRequirement.ValidateFault())
}

func TestMockCopyTask_Run(t *testing.T) {
	task := &mockCopyTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewCopyFileTask(t *testing.T) {
	m := &mockCopyFileTask{}
	task := NewCopyFileTask(m)
	assert.NotNil(t, task)
}

func TestCopyFileTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockCopyFileTask{}
			m.SetPool(pool)
			task := &CopyFileTask{copyFileTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestCopyFileTask_TriggerFault(t *testing.T) {
	m := &mockCopyFileTask{}
	task := &CopyFileTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.copyFileTaskRequirement.ValidateFault())
}

func TestMockCopyFileTask_Run(t *testing.T) {
	task := &mockCopyFileTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewCopyLargeFileTask(t *testing.T) {
	m := &mockCopyLargeFileTask{}
	task := NewCopyLargeFileTask(m)
	assert.NotNil(t, task)
}

func TestCopyLargeFileTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockCopyLargeFileTask{}
			m.SetPool(pool)
			task := &CopyLargeFileTask{copyLargeFileTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestCopyLargeFileTask_TriggerFault(t *testing.T) {
	m := &mockCopyLargeFileTask{}
	task := &CopyLargeFileTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.copyLargeFileTaskRequirement.ValidateFault())
}

func TestMockCopyLargeFileTask_Run(t *testing.T) {
	task := &mockCopyLargeFileTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewCopyPartialFileTask(t *testing.T) {
	m := &mockCopyPartialFileTask{}
	task := NewCopyPartialFileTask(m)
	assert.NotNil(t, task)
}

func TestCopyPartialFileTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockCopyPartialFileTask{}
			m.SetPool(pool)
			task := &CopyPartialFileTask{copyPartialFileTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestCopyPartialFileTask_TriggerFault(t *testing.T) {
	m := &mockCopyPartialFileTask{}
	task := &CopyPartialFileTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.copyPartialFileTaskRequirement.ValidateFault())
}

func TestMockCopyPartialFileTask_Run(t *testing.T) {
	task := &mockCopyPartialFileTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewCopyPartialStreamTask(t *testing.T) {
	m := &mockCopyPartialStreamTask{}
	task := NewCopyPartialStreamTask(m)
	assert.NotNil(t, task)
}

func TestCopyPartialStreamTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockCopyPartialStreamTask{}
			m.SetPool(pool)
			task := &CopyPartialStreamTask{copyPartialStreamTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestCopyPartialStreamTask_TriggerFault(t *testing.T) {
	m := &mockCopyPartialStreamTask{}
	task := &CopyPartialStreamTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.copyPartialStreamTaskRequirement.ValidateFault())
}

func TestMockCopyPartialStreamTask_Run(t *testing.T) {
	task := &mockCopyPartialStreamTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewCopySmallFileTask(t *testing.T) {
	m := &mockCopySmallFileTask{}
	task := NewCopySmallFileTask(m)
	assert.NotNil(t, task)
}

func TestCopySmallFileTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockCopySmallFileTask{}
			m.SetPool(pool)
			task := &CopySmallFileTask{copySmallFileTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestCopySmallFileTask_TriggerFault(t *testing.T) {
	m := &mockCopySmallFileTask{}
	task := &CopySmallFileTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.copySmallFileTaskRequirement.ValidateFault())
}

func TestMockCopySmallFileTask_Run(t *testing.T) {
	task := &mockCopySmallFileTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewCopyStreamTask(t *testing.T) {
	m := &mockCopyStreamTask{}
	task := NewCopyStreamTask(m)
	assert.NotNil(t, task)
}

func TestCopyStreamTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockCopyStreamTask{}
			m.SetPool(pool)
			task := &CopyStreamTask{copyStreamTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestCopyStreamTask_TriggerFault(t *testing.T) {
	m := &mockCopyStreamTask{}
	task := &CopyStreamTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.copyStreamTaskRequirement.ValidateFault())
}

func TestMockCopyStreamTask_Run(t *testing.T) {
	task := &mockCopyStreamTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewDeleteDirTask(t *testing.T) {
	m := &mockDeleteDirTask{}
	task := NewDeleteDirTask(m)
	assert.NotNil(t, task)
}

func TestDeleteDirTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockDeleteDirTask{}
			m.SetPool(pool)
			task := &DeleteDirTask{deleteDirTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestDeleteDirTask_TriggerFault(t *testing.T) {
	m := &mockDeleteDirTask{}
	task := &DeleteDirTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.deleteDirTaskRequirement.ValidateFault())
}

func TestMockDeleteDirTask_Run(t *testing.T) {
	task := &mockDeleteDirTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewDeleteFileTask(t *testing.T) {
	m := &mockDeleteFileTask{}
	task := NewDeleteFileTask(m)
	assert.NotNil(t, task)
}

func TestDeleteFileTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockDeleteFileTask{}
			m.SetPool(pool)
			task := &DeleteFileTask{deleteFileTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestDeleteFileTask_TriggerFault(t *testing.T) {
	m := &mockDeleteFileTask{}
	task := &DeleteFileTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.deleteFileTaskRequirement.ValidateFault())
}

func TestMockDeleteFileTask_Run(t *testing.T) {
	task := &mockDeleteFileTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewDeleteStorageTask(t *testing.T) {
	m := &mockDeleteStorageTask{}
	task := NewDeleteStorageTask(m)
	assert.NotNil(t, task)
}

func TestDeleteStorageTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockDeleteStorageTask{}
			m.SetPool(pool)
			task := &DeleteStorageTask{deleteStorageTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestDeleteStorageTask_TriggerFault(t *testing.T) {
	m := &mockDeleteStorageTask{}
	task := &DeleteStorageTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.deleteStorageTaskRequirement.ValidateFault())
}

func TestMockDeleteStorageTask_Run(t *testing.T) {
	task := &mockDeleteStorageTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewDeleteStorageForceTask(t *testing.T) {
	m := &mockDeleteStorageForceTask{}
	task := NewDeleteStorageForceTask(m)
	assert.NotNil(t, task)
}

func TestDeleteStorageForceTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockDeleteStorageForceTask{}
			m.SetPool(pool)
			task := &DeleteStorageForceTask{deleteStorageForceTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestDeleteStorageForceTask_TriggerFault(t *testing.T) {
	m := &mockDeleteStorageForceTask{}
	task := &DeleteStorageForceTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.deleteStorageForceTaskRequirement.ValidateFault())
}

func TestMockDeleteStorageForceTask_Run(t *testing.T) {
	task := &mockDeleteStorageForceTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewFileMD5SumTask(t *testing.T) {
	m := &mockFileMD5SumTask{}
	task := NewFileMD5SumTask(m)
	assert.NotNil(t, task)
}

func TestFileMD5SumTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockFileMD5SumTask{}
			m.SetPool(pool)
			task := &FileMD5SumTask{fileMD5SumTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestFileMD5SumTask_TriggerFault(t *testing.T) {
	m := &mockFileMD5SumTask{}
	task := &FileMD5SumTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.fileMD5SumTaskRequirement.ValidateFault())
}

func TestMockFileMD5SumTask_Run(t *testing.T) {
	task := &mockFileMD5SumTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewFileUploadTask(t *testing.T) {
	m := &mockFileUploadTask{}
	task := NewFileUploadTask(m)
	assert.NotNil(t, task)
}

func TestFileUploadTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockFileUploadTask{}
			m.SetPool(pool)
			task := &FileUploadTask{fileUploadTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestFileUploadTask_TriggerFault(t *testing.T) {
	m := &mockFileUploadTask{}
	task := &FileUploadTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.fileUploadTaskRequirement.ValidateFault())
}

func TestMockFileUploadTask_Run(t *testing.T) {
	task := &mockFileUploadTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewListTask(t *testing.T) {
	m := &mockListTask{}
	task := NewListTask(m)
	assert.NotNil(t, task)
}

func TestListTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockListTask{}
			m.SetPool(pool)
			task := &ListTask{listTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestListTask_TriggerFault(t *testing.T) {
	m := &mockListTask{}
	task := &ListTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.listTaskRequirement.ValidateFault())
}

func TestMockListTask_Run(t *testing.T) {
	task := &mockListTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewMakeBucketTask(t *testing.T) {
	m := &mockMakeBucketTask{}
	task := NewMakeBucketTask(m)
	assert.NotNil(t, task)
}

func TestMakeBucketTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockMakeBucketTask{}
			m.SetPool(pool)
			task := &MakeBucketTask{makeBucketTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestMakeBucketTask_TriggerFault(t *testing.T) {
	m := &mockMakeBucketTask{}
	task := &MakeBucketTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.makeBucketTaskRequirement.ValidateFault())
}

func TestMockMakeBucketTask_Run(t *testing.T) {
	task := &mockMakeBucketTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewMultipartCompleteTask(t *testing.T) {
	m := &mockMultipartCompleteTask{}
	task := NewMultipartCompleteTask(m)
	assert.NotNil(t, task)
}

func TestMultipartCompleteTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockMultipartCompleteTask{}
			m.SetPool(pool)
			task := &MultipartCompleteTask{multipartCompleteTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestMultipartCompleteTask_TriggerFault(t *testing.T) {
	m := &mockMultipartCompleteTask{}
	task := &MultipartCompleteTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.multipartCompleteTaskRequirement.ValidateFault())
}

func TestMockMultipartCompleteTask_Run(t *testing.T) {
	task := &mockMultipartCompleteTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewMultipartFileUploadTask(t *testing.T) {
	m := &mockMultipartFileUploadTask{}
	task := NewMultipartFileUploadTask(m)
	assert.NotNil(t, task)
}

func TestMultipartFileUploadTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockMultipartFileUploadTask{}
			m.SetPool(pool)
			task := &MultipartFileUploadTask{multipartFileUploadTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestMultipartFileUploadTask_TriggerFault(t *testing.T) {
	m := &mockMultipartFileUploadTask{}
	task := &MultipartFileUploadTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.multipartFileUploadTaskRequirement.ValidateFault())
}

func TestMockMultipartFileUploadTask_Run(t *testing.T) {
	task := &mockMultipartFileUploadTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewMultipartInitTask(t *testing.T) {
	m := &mockMultipartInitTask{}
	task := NewMultipartInitTask(m)
	assert.NotNil(t, task)
}

func TestMultipartInitTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockMultipartInitTask{}
			m.SetPool(pool)
			task := &MultipartInitTask{multipartInitTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestMultipartInitTask_TriggerFault(t *testing.T) {
	m := &mockMultipartInitTask{}
	task := &MultipartInitTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.multipartInitTaskRequirement.ValidateFault())
}

func TestMockMultipartInitTask_Run(t *testing.T) {
	task := &mockMultipartInitTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewMultipartStreamUploadTask(t *testing.T) {
	m := &mockMultipartStreamUploadTask{}
	task := NewMultipartStreamUploadTask(m)
	assert.NotNil(t, task)
}

func TestMultipartStreamUploadTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockMultipartStreamUploadTask{}
			m.SetPool(pool)
			task := &MultipartStreamUploadTask{multipartStreamUploadTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestMultipartStreamUploadTask_TriggerFault(t *testing.T) {
	m := &mockMultipartStreamUploadTask{}
	task := &MultipartStreamUploadTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.multipartStreamUploadTaskRequirement.ValidateFault())
}

func TestMockMultipartStreamUploadTask_Run(t *testing.T) {
	task := &mockMultipartStreamUploadTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewObjectListTask(t *testing.T) {
	m := &mockObjectListTask{}
	task := NewObjectListTask(m)
	assert.NotNil(t, task)
}

func TestObjectListTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockObjectListTask{}
			m.SetPool(pool)
			task := &ObjectListTask{objectListTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestObjectListTask_TriggerFault(t *testing.T) {
	m := &mockObjectListTask{}
	task := &ObjectListTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.objectListTaskRequirement.ValidateFault())
}

func TestMockObjectListTask_Run(t *testing.T) {
	task := &mockObjectListTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewObjectListAsyncTask(t *testing.T) {
	m := &mockObjectListAsyncTask{}
	task := NewObjectListAsyncTask(m)
	assert.NotNil(t, task)
}

func TestObjectListAsyncTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockObjectListAsyncTask{}
			m.SetPool(pool)
			task := &ObjectListAsyncTask{objectListAsyncTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestObjectListAsyncTask_TriggerFault(t *testing.T) {
	m := &mockObjectListAsyncTask{}
	task := &ObjectListAsyncTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.objectListAsyncTaskRequirement.ValidateFault())
}

func TestMockObjectListAsyncTask_Run(t *testing.T) {
	task := &mockObjectListAsyncTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewObjectPresignTask(t *testing.T) {
	m := &mockObjectPresignTask{}
	task := NewObjectPresignTask(m)
	assert.NotNil(t, task)
}

func TestObjectPresignTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockObjectPresignTask{}
			m.SetPool(pool)
			task := &ObjectPresignTask{objectPresignTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestObjectPresignTask_TriggerFault(t *testing.T) {
	m := &mockObjectPresignTask{}
	task := &ObjectPresignTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.objectPresignTaskRequirement.ValidateFault())
}

func TestMockObjectPresignTask_Run(t *testing.T) {
	task := &mockObjectPresignTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewObjectStatTask(t *testing.T) {
	m := &mockObjectStatTask{}
	task := NewObjectStatTask(m)
	assert.NotNil(t, task)
}

func TestObjectStatTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockObjectStatTask{}
			m.SetPool(pool)
			task := &ObjectStatTask{objectStatTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestObjectStatTask_TriggerFault(t *testing.T) {
	m := &mockObjectStatTask{}
	task := &ObjectStatTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.objectStatTaskRequirement.ValidateFault())
}

func TestMockObjectStatTask_Run(t *testing.T) {
	task := &mockObjectStatTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewPresignTask(t *testing.T) {
	m := &mockPresignTask{}
	task := NewPresignTask(m)
	assert.NotNil(t, task)
}

func TestPresignTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockPresignTask{}
			m.SetPool(pool)
			task := &PresignTask{presignTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestPresignTask_TriggerFault(t *testing.T) {
	m := &mockPresignTask{}
	task := &PresignTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.presignTaskRequirement.ValidateFault())
}

func TestMockPresignTask_Run(t *testing.T) {
	task := &mockPresignTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewStatTask(t *testing.T) {
	m := &mockStatTask{}
	task := NewStatTask(m)
	assert.NotNil(t, task)
}

func TestStatTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockStatTask{}
			m.SetPool(pool)
			task := &StatTask{statTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestStatTask_TriggerFault(t *testing.T) {
	m := &mockStatTask{}
	task := &StatTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.statTaskRequirement.ValidateFault())
}

func TestMockStatTask_Run(t *testing.T) {
	task := &mockStatTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}

func TestNewStreamMD5SumTask(t *testing.T) {
	m := &mockStreamMD5SumTask{}
	task := NewStreamMD5SumTask(m)
	assert.NotNil(t, task)
}

func TestStreamMD5SumTask_Run(t *testing.T) {
	cases := []struct {
		name     string
		hasFault bool
		hasCall  bool
		gotCall  bool
	}{
		{
			"has fault",
			true,
			false,
			false,
		},
		{
			"no fault",
			false,
			true,
			false,
		},
	}

	for _, v := range cases {
		t.Run(v.name, func(t *testing.T) {
			pool := navvy.NewPool(10)

			m := &mockStreamMD5SumTask{}
			m.SetPool(pool)
			task := &StreamMD5SumTask{streamMD5SumTaskRequirement: m}

			err := errors.New("test error")
			if v.hasFault {
				task.SetFault(err)
			}
			task.GetScheduler.Sync(task,
				func(todoist types.TaskFunc) navvy.Task {
					x := utils.NewCallbackTask(func() {
						v.gotCall = true
					})
					return x
				})

			task.Run()
			pool.Wait()

			assert.Equal(t, v.hasCall, v.gotCall)
		})
	}
}

func TestStreamMD5SumTask_TriggerFault(t *testing.T) {
	m := &mockStreamMD5SumTask{}
	task := &StreamMD5SumTask{m}
	err := errors.New("test error")
	task.TriggerFault(err)
	assert.True(t, task.streamMD5SumTaskRequirement.ValidateFault())
}

func TestMockStreamMD5SumTask_Run(t *testing.T) {
	task := &mockStreamMD5SumTask{}
	assert.Panics(t, func() {
		task.Run()
	})
}
